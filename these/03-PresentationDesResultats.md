---
title: Présentation des résultats
slug: resultats
layout: post
---

1. [Hypothèse 1](#hypothèse-1)
   1. [Hypothèse 1 - Présentation du *proof of concept*](#hypothèse-1---présentation-du-proof-of-concept)
   1. [Hypothèse 1 - **Critères 1** : Pendant le développement](#hypothèse-1---critères-1--pendant-le-développement)
      1. [Hypothèse 1 - **Critère 1.1** : Le temps de développement](#hypothèse-1---critère-11--le-temps-de-développement)
      1. [Hypothèse 1 - **Critère 1.2** : Les limitations des technologies](#hypothèse-1---critère-12--les-limitations-des-technologies)
   1. [Hypothèse 1 - **Critères 2** : Après le développement](#hypothèse-1---critères-2--après-le-développement)
      1. [Hypothèse 1 - **Critères 2.1** : Le déploiement](#hypothèse-1---critères-21--le-déploiement)
         1. [Pour des "particuliers"](#pour-des-particuliers)
      1. [Hypothèse 1 - **Critères 2.2** : La maintenance](#hypothèse-1---critères-22--la-maintenance)
      1. [Hypothèse 1 - **Critères 2.3** : La réutilisation](#hypothèse-1---critères-23--la-réutilisation)
   1. [Hypothèse 1 - **Critères 3** : Le résultat](#hypothèse-1---critères-3--le-résultat)
      1. [Hypothèse 1 - **Critères 3.1** : Utilisation du processeur et de la mémoire](#hypothèse-1---critères-31--utilisation-du-processeur-et-de-la-mémoire)
      1. [Hypothèse 1 - **Critères 3.2** : Temps de réponse moyen](#hypothèse-1---critères-32--temps-de-réponse-moyen)
      1. [Hypothèse 1 - **Critère 3.3** : Le poids de l'exécutable](#hypothèse-1---critère-33--le-poids-de-lexécutable)
   1. [Hypothèse 1 - Synthèse des critères](#hypothèse-1---synthèse-des-critères)
   1. [Hypothèse 1 - Conclusion](#hypothèse-1---conclusion)
1. [Hypothèse 2](#hypothèse-2)
   1. [Hypothèse 2 - Présentation du *proof of concept*](#hypothèse-2---présentation-du-proof-of-concept)
   1. [Hypothèse 2 - **Critères 1** : Pendant le développement](#hypothèse-2---critères-1--pendant-le-développement)
      1. [Hypothèse 2 - **Critère 1.1** : Le temps de développement](#hypothèse-2---critère-11--le-temps-de-développement)
      1. [Hypothèse 2 - **Critère 1.2** : Les limitations des technologies](#hypothèse-2---critère-12--les-limitations-des-technologies)
   1. [Hypothèse 2 - **Critères 2** : Après le développement](#hypothèse-2---critères-2--après-le-développement)
      1. [Hypothèse 2 - **Critères 2.1** : Le déploiement](#hypothèse-2---critères-21--le-déploiement)
      1. [Hypothèse 2 - **Critères 2.2** : La maintenance](#hypothèse-2---critères-22--la-maintenance)
      1. [Hypothèse 2 - **Critères 2.3** : La réutilisation](#hypothèse-2---critères-23--la-réutilisation)
   1. [Hypothèse 2 - **Critères 3** : Le résultat](#hypothèse-2---critères-3--le-résultat)
      1. [Hypothèse 2 - **Critères 3.1** : Utilisation du processeur et de la mémoire](#hypothèse-2---critères-31--utilisation-du-processeur-et-de-la-mémoire)
      1. [Hypothèse 2 - **Critères 3.2** : Temps de réponse moyen](#hypothèse-2---critères-32--temps-de-réponse-moyen)
      1. [Hypothèse 2 - **Critère 3.3** : Le poids de l'exécutable](#hypothèse-2---critère-33--le-poids-de-lexécutable)
   1. [Hypothèse 2 - Synthèse des critères](#hypothèse-2---synthèse-des-critères)
   1. [Hypothèse 2 - Conclusion](#hypothèse-2---conclusion)
1. [Hypothèse 3](#hypothèse-3)
   1. [Hypothèse 3 - Présentation du *proof of concept*](#hypothèse-3---présentation-du-proof-of-concept)
   1. [Hypothèse 3 - **Critères 1** : Pendant le développement](#hypothèse-3---critères-1--pendant-le-développement)
      1. [Hypothèse 3 - **Critère 1.1** : Le temps de développement](#hypothèse-3---critère-11--le-temps-de-développement)
      1. [Hypothèse 3 - **Critère 1.2** : Les limitations des technologies](#hypothèse-3---critère-12--les-limitations-des-technologies)
   1. [Hypothèse 3 - **Critères 2** : Après le développement](#hypothèse-3---critères-2--après-le-développement)
      1. [Hypothèse 3 - **Critères 2.1** : Le déploiement](#hypothèse-3---critères-21--le-déploiement)
      1. [Hypothèse 3 - **Critères 2.2** : La maintenance](#hypothèse-3---critères-22--la-maintenance)
      1. [Hypothèse 3 - **Critères 2.3** : La réutilisation](#hypothèse-3---critères-23--la-réutilisation)
   1. [Hypothèse 3 - **Critères 3** : Le résultat](#hypothèse-3---critères-3--le-résultat)
      1. [Hypothèse 3 - **Critères 3.1** : Utilisation du processeur et de la mémoire](#hypothèse-3---critères-31--utilisation-du-processeur-et-de-la-mémoire)
      1. [Hypothèse 3 - **Critères 3.2** : Temps de réponse moyen](#hypothèse-3---critères-32--temps-de-réponse-moyen)
      1. [Hypothèse 3 - **Critère 3.3** : Le poids de l'exécutable](#hypothèse-3---critère-33--le-poids-de-lexécutable)
   1. [Hypothèse 3 - Synthèse des critères](#hypothèse-3---synthèse-des-critères)
   1. [Hypothèse 3 - Conclusion](#hypothèse-3---conclusion)
1. [Hypothèse 4](#hypothèse-4)
   1. [Hypothèse 4 - Présentation du *proof of concept*](#hypothèse-4---présentation-du-proof-of-concept)
   1. [Hypothèse 4 - **Critères 1** : Pendant le développement](#hypothèse-4---critères-1--pendant-le-développement)
      1. [Hypothèse 4 - **Critère 1.1** : Le temps de développement](#hypothèse-4---critère-11--le-temps-de-développement)
      1. [Hypothèse 4 - **Critère 1.2** : Les limitations des technologies](#hypothèse-4---critère-12--les-limitations-des-technologies)
   1. [Hypothèse 4 - **Critères 2** : Après le développement](#hypothèse-4---critères-2--après-le-développement)
      1. [Hypothèse 4 - **Critères 2.1** : Le déploiement](#hypothèse-4---critères-21--le-déploiement)
      1. [Hypothèse 4 - **Critères 2.2** : La maintenance](#hypothèse-4---critères-22--la-maintenance)
      1. [Hypothèse 4 - **Critères 2.3** : La réutilisation](#hypothèse-4---critères-23--la-réutilisation)
   1. [Hypothèse 4 - **Critères 3** : Le résultat](#hypothèse-4---critères-3--le-résultat)
      1. [Hypothèse 4 - **Critères 3.1** : Utilisation du processeur et de la mémoire](#hypothèse-4---critères-31--utilisation-du-processeur-et-de-la-mémoire)
      1. [Hypothèse 4 - **Critères 3.2** : Temps de réponse moyen](#hypothèse-4---critères-32--temps-de-réponse-moyen)
      1. [Hypothèse 4 - **Critère 3.3** : Le poids de l'exécutable](#hypothèse-4---critère-33--le-poids-de-lexécutable)
   1. [Hypothèse 4 - Synthèse des critères](#hypothèse-4---synthèse-des-critères)
   1. [Hypothèse 4 - Conclusion](#hypothèse-4---conclusion)
1. [Hypothèse 5](#hypothèse-5)
   1. [Hypothèse 5 - Présentation du *proof of concept*](#hypothèse-5---présentation-du-proof-of-concept)
   1. [Hypothèse 5 - **Critères 1** : Pendant le développement](#hypothèse-5---critères-1--pendant-le-développement)
      1. [Hypothèse 5 - **Critère 1.1** : Le temps de développement](#hypothèse-5---critère-11--le-temps-de-développement)
      1. [Hypothèse 5 - **Critère 1.2** : Les limitations des technologies](#hypothèse-5---critère-12--les-limitations-des-technologies)
   1. [Hypothèse 5 - **Critères 2** : Après le développement](#hypothèse-5---critères-2--après-le-développement)
      1. [Hypothèse 5 - **Critères 2.1** : Le déploiement](#hypothèse-5---critères-21--le-déploiement)
      1. [Hypothèse 5 - **Critères 2.2** : La maintenance](#hypothèse-5---critères-22--la-maintenance)
      1. [Hypothèse 5 - **Critères 2.3** : La réutilisation](#hypothèse-5---critères-23--la-réutilisation)
   1. [Hypothèse 5 - **Critères 3** : Le résultat](#hypothèse-5---critères-3--le-résultat)
      1. [Hypothèse 5 - **Critères 3.1** : Utilisation du processeur et de la mémoire](#hypothèse-5---critères-31--utilisation-du-processeur-et-de-la-mémoire)
      1. [Hypothèse 5 - **Critères 3.2** : Temps de réponse moyen](#hypothèse-5---critères-32--temps-de-réponse-moyen)
      1. [Hypothèse 5 - **Critère 3.3** : Le poids de l'exécutable](#hypothèse-5---critère-33--le-poids-de-lexécutable)
   1. [Hypothèse 5 - Synthèse des critères](#hypothèse-5---synthèse-des-critères)
   1. [Hypothèse 5 - Conclusion](#hypothèse-5---conclusion)

## Hypothèse 1

> Une application native pour chaque appareil cible.

### Hypothèse 1 - Présentation du *proof of concept*

Cette hypothèse consiste à penser que développer une application native pour chaque appareil cible est une solution efficace d'architecture applicative.

Pour tenter de le démontrer, nous allons réaliser une application dans chaque langages natifs de nos cibles, à savoir :

- Linux : [*Rust/C*](https://github.com/gothinkster/rust-realworld-example-app)
- Windows : [*C#* avec .NET](https://github.com/gothinkster/aspnetcore-realworld-example-app)
- macOS : [*Swift* avec Vapor](https://github.com/amadeu01/swift-vapor-conduit-example-app)
- Android : [*Kotlin/Java*](https://github.com/DrewCarlson/realworld-android-kotlin)
- iOS : [*Swift*](https://github.com/littleStudent/swift-realworld-example)

Note : Les langages séparés par une barre oblique représentent à gauche le langage utilisé pour le *proof of concept* et à droite le langage équivalent ou transpilé<!-- TODO: définir transpiler -->. Quand un langage est suivit de "avec X", on désigne le *framework*<!-- TODO: définir framework --> utilisé.

### Hypothèse 1 - **Critères 1** : Pendant le développement

#### Hypothèse 1 - **Critère 1.1** : Le temps de développement

Pour ces cinq applications différentes dont le code ne peux être partagé (même entre Mac et iOS qui partagent le même langage car les spécificité sont trop grande pour que la réutilisation du code puisse avoir un véritable impact) les temps de développement sont relativement ??? <!-- TODO: indiquer les comparaison -->

<!-- TODO: estimer les temps pour l'hypothèse1 -->

#### Hypothèse 1 - **Critère 1.2** : Les limitations des technologies

Ces cinq applications ont donc comme principe d'être chacune native et donc par définition d'avoir un accès à toutes les fonctionnalités offertes par le système d'exploitation cible, et cela sans charge supplémentaire de travail.\
Certains systèmes d'exploitation ajoutent d'ailleurs à cela une couche de sécurité supplémentaire comme Android qui demande la permission à l'utilisateur avant d'accéder à des fonctionnalités natives.

Parmi ces fonctionnalités, on retrouve fréquemment :

- Le stockage de fichiers
- L'accès à Internet
- L'accès aux informations de l'appareil (Marque, numéro de téléphone, composants etc.)
- L'accès aux périphériques de l'appareil (caméra, microphone, GPS etc.)

Afin de juger des libertés d'accès de tous ces logiciels, nous leur donneront une note arbitraire qui s'étend de 0 (aucun accès aux fonctionnalités natives) à 5 (libre accès à toutes les fonctionnalités).

| Système d'exploitation | Langage | Note sur 5 |
| ---------------------- | ------- | ---------: |
| Linux                  | Rust    | 5.0        |
| Windows                | C#      | 5.0        |
| macOS                  | Swift   | 5.0        |
| Android                | Kotlin  | 4.0        |
| iOS                    | Swift   | 4.0        |
| **Moyenne**            |         | **4.6**    |

Sans surprise, chaque application reçoit une note proche de maximale étant donné le degré de liberté offert par les applications natives.\
Il est à noté que si Android et iOS ont tout deux des notes légèrement plus basse, c'est en raison de la requête faite à l'utilisateur d'accéder aux fonctionnalités. Quand bien même cette notion est très bénéfique d'un point de vue de la sécurité informatique, nous jugeons ici la degré de liberté d'accès exclusivement.

### Hypothèse 1 - **Critères 2** : Après le développement

#### Hypothèse 1 - **Critères 2.1** : Le déploiement

Nous allons réitérer la méthode de la notation afin de juger la facilité et la rapidité d'un déploiement sur ces différents systèmes d'exploitation.

Pour cela nous allons juger en deux parties, à savoir le déploiement pour des "particuliers" et le déploiement pour le grand publique.\
Par "particuliers" nous entendons ici par exemple des entreprises.

##### Pour des "particuliers"

| Système d'exploitation | Note sur 5 |
| ---------------------- | ---------: |
| Linux                  | 5.0        |
| Windows                | 4.0        |
| macOS                  | 5.0        |
| Android                | 5.0        |
| iOS                    | 2.0        |
| **Moyenne**            | **4.2**    |

Dans le cas de Linux, macOS, Windows Android, il est possible de créer des fichiers uniques qui servent de "containers" à l'application et qui, une fois exécutés, installent directement le logiciel.

Linux offre une grande flexibilité ainsi que de nombreux outils pour faciliter le déploiement (*Ansible*, *Rudder* etc.). macOS et Android, tournant tous deux sous un noyau Linux, profitent d'une flexibilité similaire.

Dans le cas de Windows, la présence d'un installeur obligatoire et les verrous mis sur les procédures d'installation peuvent parfois rendre la tâche légèrement plus compliquée.

Enfin, sur iOS, afin de déployer une application, il est impératif de passer par un *store* (Marchés d'applications) même privé afin de rendre disponible le résultat. Chaque applicatif passant sur le store sera aussi testé par des employés d'Apple, ajoutant une charge temporelle supplémentaire.

#### Hypothèse 1 - **Critères 2.2** : La maintenance

La maintenance peut être perçu comme un second déploiement. Nous devons juger de la vitesse et la facilité de l'intervention en cas de mise à jour.

| Système d'exploitation | Note sur 5 |
| ---------------------- | ---------: |
| Linux                  | 4.5        |
| Windows                | 4.5        |
| macOS                  | 4.5        |
| Android                | 5.0        |
| iOS                    | 5.0        |
| **Moyenne**            | **4.7**    |

Chaque système d'exploitation est très réceptif quand à la mise à jour des applications natives. Android et iOS proposent des systèmes intégrés dans leurs *stores* là ou les mises à jours sur les systèmes d'exploitation bureau doivent êtres implémentés manuellement.

#### Hypothèse 1 - **Critères 2.3** : La réutilisation

Voyons maintenant à quel point le code source utilisé dans ce projet pourrait-être utilisé à nouveau dans un autre projet.\
Voici un apercu de la manière dont le code pourrait être réutilisé :

<div class="mermaid">
graph LR
   subgraph Projet Actuel
      L1[Linux]
      W1[Windows]
      M1[macOS]
      A1[Android]
      I1[iOS]
   end
   subgraph Prochain Projet
      L2[Linux]
      W2[Windows]
      M2[macOS]
      I2[iOS]
      A2[Android]
   end
   L1 -- Rust --> L2
   W1 -- C# --> W2
   M1 -- Swift Bureau --> M2
   M1 -. Swift Bureau .-> I2
   A1 -- Kotlin --> A2
   I1 -- Swift Mobile --> I2
   I1 -. Swift Mobile .-> M2
</div>

Comme exprimé précédemment, même si les applications macOS et iOS sont développée dans les mêmes langages, tout le code ne peux pas être transposé de l'un à l'autre, seul quelques fonctionnalités très communes et qui ne touchent pas à l'affichage des données le peuvent.

Nous pouvons voir dans ce cas que si l'on quantifie les liens qu'il est possible de faire entre les applications (une flèche vaut 1 point, et 0.5 point pour les flèches partielles), nous obtenons ce tableau :

| Système d'exploitation | Langage | Partageable sur X projets |
| ---------------------- | ------- | ------------------------: |
| Linux                  | Rust    | 1.0                       |
| Windows                | C#      | 1.0                       |
| macOS                  | Swift   | 1.5                       |
| Android                | Kotlin  | 1.0                       |
| iOS                    | Swift   | 1.5                       |
| **Moyenne**            |         | **1.2**                   |

Attention, dans ce cas précis, les valeurs ne sont pas des notes sur 5 mais bien des ratios que nous pourront comparer plus tard. Actuellement, la moyenne de **1.2** représente un taux de partage de code assez faible puisque le code d'un logiciel n'est réutilisable que pour un logiciel d'un langage identique.

### Hypothèse 1 - **Critères 3** : Le résultat

<!-- TODO: mesurer -->

#### Hypothèse 1 - **Critères 3.1** : Utilisation du processeur et de la mémoire

#### Hypothèse 1 - **Critères 3.2** : Temps de réponse moyen

#### Hypothèse 1 - **Critère 3.3** : Le poids de l'exécutable

### Hypothèse 1 - Synthèse des critères

- Critères 1 (Avant le développement)
  - Critère 1.1 (Temps de développement) : ??h
  - Critère 1.2 (Limitations) : 4.6 pts
- Critères 2 (Après le développement)
  - Critère 2.1 (Déploiement) : 4.2 pts
  - Critère 2.2 (Maintenance) : 4.7 pts
  - Critère 2.3 (Réutilisation) : 1.2:5
- Critères 3 (Résultat)
  - Critère 3.1 (*Benchmark*) : ??
  - Critère 3.2 (Temps de réponse) : ??ms
  - Critère 3.3 (Poids total) : ??Mb

### Hypothèse 1 - Conclusion

<!-- TODO: conclusion hypothèse 1 -->

## Hypothèse 2
<!-- TODO: Hypothèse 2 -->

> Séparer les cibles en deux grands groupes, à savoir "Logiciels Bureaux" et "Applications Mobiles" et faire deux applications natives différentes pour ces groupes.

### Hypothèse 2 - Présentation du *proof of concept*

Cette hypothèse reprend en partie le principe de l'hypothèse précédente qui décrivait les applications natives comme étants les alternatives les plus puissantes disponibles. Cependant, pour palier le nombre conséquent d'applications à développer, ce nombre est réduit au plus faible possible en cherchant des technologies capables de créer des logiciels pour les interfaces bureau et d'autres pour les interfaces mobiles.

Conserver les avantages des applications native en limitant grandement le nombre de logiciels semble être une approche prometteuse et pour le démontrer nous réaliserons une application pour chaque groupe d'appareils cibles :

- Logiciels bureau (Linux, Windows, Mac) : [**Kotlin/Java** avec Spring](https://github.com/gothinkster/kotlin-spring-realworld-example-app)
- Logiciels mobile (Android, iOS): [**Dart** avec Flutter](https://github.com/UkonnRa/flutter_realworld_app)

### Hypothèse 2 - **Critères 1** : Pendant le développement

#### Hypothèse 2 - **Critère 1.1** : Le temps de développement

Pour ces eux applications voici les temps de développement :

<!-- TODO: mesurer -->

#### Hypothèse 2 - **Critère 1.2** : Les limitations des technologies

Comme pour l'hypothèse précédente, nous allons juger les deux applications sur la libertés qu'elles offrent aux développeurs d'accéder aux fonctionnalités du système d'exploitation cible.

| Groupe de cibles | Langage | Note sur 5 |
| ---------------- | ------- | ---------: |
| Logiciel Bureau  | Kotlin  | 5.0        |
| Logiciel Mobile  | Dart    | 4.5        |
| **Moyenne**      |         | **4.8**    |

### Hypothèse 2 - **Critères 2** : Après le développement

#### Hypothèse 2 - **Critères 2.1** : Le déploiement

#### Hypothèse 2 - **Critères 2.2** : La maintenance

#### Hypothèse 2 - **Critères 2.3** : La réutilisation

### Hypothèse 2 - **Critères 3** : Le résultat

#### Hypothèse 2 - **Critères 3.1** : Utilisation du processeur et de la mémoire

#### Hypothèse 2 - **Critères 3.2** : Temps de réponse moyen

#### Hypothèse 2 - **Critère 3.3** : Le poids de l'exécutable

### Hypothèse 2 - Synthèse des critères

### Hypothèse 2 - Conclusion

## Hypothèse 3
<!-- TODO: Hypothèse 3 -->

> Une seule application web et une interface *responsive* pour tout les appareils cibles.

[Angular](https://github.com/gothinkster/angular-realworld-example-app)

### Hypothèse 3 - Présentation du *proof of concept*

### Hypothèse 3 - **Critères 1** : Pendant le développement

#### Hypothèse 3 - **Critère 1.1** : Le temps de développement

#### Hypothèse 3 - **Critère 1.2** : Les limitations des technologies

### Hypothèse 3 - **Critères 2** : Après le développement

#### Hypothèse 3 - **Critères 2.1** : Le déploiement

#### Hypothèse 3 - **Critères 2.2** : La maintenance

#### Hypothèse 3 - **Critères 2.3** : La réutilisation

### Hypothèse 3 - **Critères 3** : Le résultat

#### Hypothèse 3 - **Critères 3.1** : Utilisation du processeur et de la mémoire

#### Hypothèse 3 - **Critères 3.2** : Temps de réponse moyen

#### Hypothèse 3 - **Critère 3.3** : Le poids de l'exécutable

### Hypothèse 3 - Synthèse des critères

### Hypothèse 3 - Conclusion

## Hypothèse 4
<!-- TODO: Hypothèse 4 -->

> Une application web pour les cibles bureau et une application hybride pour les cibles mobiles

### Hypothèse 4 - Présentation du *proof of concept*

### Hypothèse 4 - **Critères 1** : Pendant le développement

#### Hypothèse 4 - **Critère 1.1** : Le temps de développement

#### Hypothèse 4 - **Critère 1.2** : Les limitations des technologies

### Hypothèse 4 - **Critères 2** : Après le développement

#### Hypothèse 4 - **Critères 2.1** : Le déploiement

#### Hypothèse 4 - **Critères 2.2** : La maintenance

#### Hypothèse 4 - **Critères 2.3** : La réutilisation

### Hypothèse 4 - **Critères 3** : Le résultat

#### Hypothèse 4 - **Critères 3.1** : Utilisation du processeur et de la mémoire

#### Hypothèse 4 - **Critères 3.2** : Temps de réponse moyen

#### Hypothèse 4 - **Critère 3.3** : Le poids de l'exécutable

### Hypothèse 4 - Synthèse des critères

### Hypothèse 4 - Conclusion

## Hypothèse 5
<!-- TODO: Hypothèse 5 -->

### Hypothèse 5 - Présentation du *proof of concept*

- Bureau (Linux, Windows, Mac) : [Angular](https://github.com/gothinkster/angular-realworld-example-app)
- Mobile (Android, iOS): [NativeScript Angular](https://github.com/nea/nativescript-realworld-example-app)

### Hypothèse 5 - **Critères 1** : Pendant le développement

#### Hypothèse 5 - **Critère 1.1** : Le temps de développement

#### Hypothèse 5 - **Critère 1.2** : Les limitations des technologies

### Hypothèse 5 - **Critères 2** : Après le développement

#### Hypothèse 5 - **Critères 2.1** : Le déploiement

#### Hypothèse 5 - **Critères 2.2** : La maintenance

#### Hypothèse 5 - **Critères 2.3** : La réutilisation

### Hypothèse 5 - **Critères 3** : Le résultat

#### Hypothèse 5 - **Critères 3.1** : Utilisation du processeur et de la mémoire

#### Hypothèse 5 - **Critères 3.2** : Temps de réponse moyen

#### Hypothèse 5 - **Critère 3.3** : Le poids de l'exécutable

### Hypothèse 5 - Synthèse des critères

### Hypothèse 5 - Conclusion
