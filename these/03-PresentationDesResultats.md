---
title: Présentation des résultats
slug: resultats
layout: post
---

1. [Hypothèse 1](#hypothèse-1)
   1. [Hypothèse 1 - Présentation du *proof of concept*](#hypothèse-1---présentation-du-proof-of-concept)
   1. [Hypothèse 1 - **Critères 1** : Pendant le développement](#hypothèse-1---critères-1--pendant-le-développement)
      1. [Hypothèse 1 - **Critère 1.1** : Le temps de développement](#hypothèse-1---critère-11--le-temps-de-développement)
      1. [Hypothèse 1 - **Critère 1.2** : Les limitations des technologies](#hypothèse-1---critère-12--les-limitations-des-technologies)
   1. [Hypothèse 1 - **Critères 2** : Après le développement](#hypothèse-1---critères-2--après-le-développement)
      1. [Hypothèse 1 - **Critères 2.1** : Le déploiement](#hypothèse-1---critères-21--le-déploiement)
      1. [Hypothèse 1 - **Critères 2.2** : La maintenance](#hypothèse-1---critères-22--la-maintenance)
      1. [Hypothèse 1 - **Critères 2.3** : La réutilisation](#hypothèse-1---critères-23--la-réutilisation)
   1. [Hypothèse 1 - **Critères 3** : Le résultat](#hypothèse-1---critères-3--le-résultat)
      1. [Hypothèse 1 - **Critères 3.1** : Utilisation du processeur et de la mémoire](#hypothèse-1---critères-31--utilisation-du-processeur-et-de-la-mémoire)
      1. [Hypothèse 1 - **Critères 3.2** : Temps de réponse moyen](#hypothèse-1---critères-32--temps-de-réponse-moyen)
      1. [Hypothèse 1 - **Critère 3.3** : Le poids de l'exécutable](#hypothèse-1---critère-33--le-poids-de-lexécutable)
   1. [Hypothèse 1 - Synthèse des critères](#hypothèse-1---synthèse-des-critères)
   1. [Hypothèse 1 - Conclusion](#hypothèse-1---conclusion)
1. [Hypothèse 2](#hypothèse-2)
   1. [Hypothèse 2 - Présentation du *proof of concept*](#hypothèse-2---présentation-du-proof-of-concept)
   1. [Hypothèse 2 - **Critères 1** : Pendant le développement](#hypothèse-2---critères-1--pendant-le-développement)
      1. [Hypothèse 2 - **Critère 1.1** : Le temps de développement](#hypothèse-2---critère-11--le-temps-de-développement)
      1. [Hypothèse 2 - **Critère 1.2** : Les limitations des technologies](#hypothèse-2---critère-12--les-limitations-des-technologies)
   1. [Hypothèse 2 - **Critères 2** : Après le développement](#hypothèse-2---critères-2--après-le-développement)
      1. [Hypothèse 2 - **Critères 2.1** : Le déploiement](#hypothèse-2---critères-21--le-déploiement)
      1. [Hypothèse 2 - **Critères 2.2** : La maintenance](#hypothèse-2---critères-22--la-maintenance)
      1. [Hypothèse 2 - **Critères 2.3** : La réutilisation](#hypothèse-2---critères-23--la-réutilisation)
   1. [Hypothèse 2 - **Critères 3** : Le résultat](#hypothèse-2---critères-3--le-résultat)
      1. [Hypothèse 2 - **Critères 3.1** : Utilisation du processeur et de la mémoire](#hypothèse-2---critères-31--utilisation-du-processeur-et-de-la-mémoire)
      1. [Hypothèse 2 - **Critères 3.2** : Temps de réponse moyen](#hypothèse-2---critères-32--temps-de-réponse-moyen)
      1. [Hypothèse 2 - **Critère 3.3** : Le poids de l'exécutable](#hypothèse-2---critère-33--le-poids-de-lexécutable)
   1. [Hypothèse 2 - Synthèse des critères](#hypothèse-2---synthèse-des-critères)
   1. [Hypothèse 2 - Conclusion](#hypothèse-2---conclusion)
1. [Hypothèse 3](#hypothèse-3)
   1. [Hypothèse 3 - Présentation du *proof of concept*](#hypothèse-3---présentation-du-proof-of-concept)
   1. [Hypothèse 3 - **Critères 1** : Pendant le développement](#hypothèse-3---critères-1--pendant-le-développement)
      1. [Hypothèse 3 - **Critère 1.1** : Le temps de développement](#hypothèse-3---critère-11--le-temps-de-développement)
      1. [Hypothèse 3 - **Critère 1.2** : Les limitations des technologies](#hypothèse-3---critère-12--les-limitations-des-technologies)
   1. [Hypothèse 3 - **Critères 2** : Après le développement](#hypothèse-3---critères-2--après-le-développement)
      1. [Hypothèse 3 - **Critères 2.1** : Le déploiement](#hypothèse-3---critères-21--le-déploiement)
      1. [Hypothèse 3 - **Critères 2.2** : La maintenance](#hypothèse-3---critères-22--la-maintenance)
      1. [Hypothèse 3 - **Critères 2.3** : La réutilisation](#hypothèse-3---critères-23--la-réutilisation)
   1. [Hypothèse 3 - **Critères 3** : Le résultat](#hypothèse-3---critères-3--le-résultat)
      1. [Hypothèse 3 - **Critères 3.1** : Utilisation du processeur et de la mémoire](#hypothèse-3---critères-31--utilisation-du-processeur-et-de-la-mémoire)
      1. [Hypothèse 3 - **Critères 3.2** : Temps de réponse moyen](#hypothèse-3---critères-32--temps-de-réponse-moyen)
      1. [Hypothèse 3 - **Critère 3.3** : Le poids de l'exécutable](#hypothèse-3---critère-33--le-poids-de-lexécutable)
   1. [Hypothèse 3 - Synthèse des critères](#hypothèse-3---synthèse-des-critères)
   1. [Hypothèse 3 - Conclusion](#hypothèse-3---conclusion)
1. [Hypothèse 4](#hypothèse-4)
   1. [Hypothèse 4 - Présentation du *proof of concept*](#hypothèse-4---présentation-du-proof-of-concept)
   1. [Hypothèse 4 - **Critères 1** : Pendant le développement](#hypothèse-4---critères-1--pendant-le-développement)
      1. [Hypothèse 4 - **Critère 1.1** : Le temps de développement](#hypothèse-4---critère-11--le-temps-de-développement)
      1. [Hypothèse 4 - **Critère 1.2** : Les limitations des technologies](#hypothèse-4---critère-12--les-limitations-des-technologies)
   1. [Hypothèse 4 - **Critères 2** : Après le développement](#hypothèse-4---critères-2--après-le-développement)
      1. [Hypothèse 4 - **Critères 2.1** : Le déploiement](#hypothèse-4---critères-21--le-déploiement)
      1. [Hypothèse 4 - **Critères 2.2** : La maintenance](#hypothèse-4---critères-22--la-maintenance)
      1. [Hypothèse 4 - **Critères 2.3** : La réutilisation](#hypothèse-4---critères-23--la-réutilisation)
   1. [Hypothèse 4 - **Critères 3** : Le résultat](#hypothèse-4---critères-3--le-résultat)
      1. [Hypothèse 4 - **Critères 3.1** : Utilisation du processeur et de la mémoire](#hypothèse-4---critères-31--utilisation-du-processeur-et-de-la-mémoire)
      1. [Hypothèse 4 - **Critères 3.2** : Temps de réponse moyen](#hypothèse-4---critères-32--temps-de-réponse-moyen)
      1. [Hypothèse 4 - **Critère 3.3** : Le poids de l'exécutable](#hypothèse-4---critère-33--le-poids-de-lexécutable)
   1. [Hypothèse 4 - Synthèse des critères](#hypothèse-4---synthèse-des-critères)
   1. [Hypothèse 4 - Conclusion](#hypothèse-4---conclusion)
1. [Hypothèse 5](#hypothèse-5)
   1. [Hypothèse 5 - Présentation du *proof of concept*](#hypothèse-5---présentation-du-proof-of-concept)
   1. [Hypothèse 5 - **Critères 1** : Pendant le développement](#hypothèse-5---critères-1--pendant-le-développement)
      1. [Hypothèse 5 - **Critère 1.1** : Le temps de développement](#hypothèse-5---critère-11--le-temps-de-développement)
      1. [Hypothèse 5 - **Critère 1.2** : Les limitations des technologies](#hypothèse-5---critère-12--les-limitations-des-technologies)
   1. [Hypothèse 5 - **Critères 2** : Après le développement](#hypothèse-5---critères-2--après-le-développement)
      1. [Hypothèse 5 - **Critères 2.1** : Le déploiement](#hypothèse-5---critères-21--le-déploiement)
      1. [Hypothèse 5 - **Critères 2.2** : La maintenance](#hypothèse-5---critères-22--la-maintenance)
      1. [Hypothèse 5 - **Critères 2.3** : La réutilisation](#hypothèse-5---critères-23--la-réutilisation)
   1. [Hypothèse 5 - **Critères 3** : Le résultat](#hypothèse-5---critères-3--le-résultat)
      1. [Hypothèse 5 - **Critères 3.1** : Utilisation du processeur et de la mémoire](#hypothèse-5---critères-31--utilisation-du-processeur-et-de-la-mémoire)
      1. [Hypothèse 5 - **Critères 3.2** : Temps de réponse moyen](#hypothèse-5---critères-32--temps-de-réponse-moyen)
      1. [Hypothèse 5 - **Critère 3.3** : Le poids de l'exécutable](#hypothèse-5---critère-33--le-poids-de-lexécutable)
   1. [Hypothèse 5 - Synthèse des critères](#hypothèse-5---synthèse-des-critères)
   1. [Hypothèse 5 - Conclusion](#hypothèse-5---conclusion)

## Hypothèse 1

> Une application native pour chaque appareil cible.

### Hypothèse 1 - Présentation du *proof of concept*

Cette hypothèse consiste à penser que développer une application native pour chaque appareil cible est une solution efficace d'architecture applicative.

Pour tenter de le démontrer, nous allons réaliser une application dans chaque langages natifs de nos cibles, à savoir :

- Linux : [*Rust/C*](https://github.com/gothinkster/rust-realworld-example-app)
- Windows : [*C#* avec .NET](https://github.com/gothinkster/aspnetcore-realworld-example-app)
- macOS : [*Swift* avec Vapor](https://github.com/amadeu01/swift-vapor-conduit-example-app)
- Android : [*Kotlin/Java*](https://github.com/DrewCarlson/realworld-android-kotlin)
- iOS : [*Swift*](https://github.com/littleStudent/swift-realworld-example)

Note : Les langages séparés par une barre oblique représentent à gauche le langage utilisé pour le *proof of concept* et à droite le langage équivalent ou transpilé<!-- TODO: définir transpiler -->. Quand un langage est suivit de "avec X", on désigne le *framework*<!-- TODO: définir framework --> utilisé.

### Hypothèse 1 - **Critères 1** : Pendant le développement

#### Hypothèse 1 - **Critère 1.1** : Le temps de développement

Pour ces cinq applications différentes dont le code ne peux être partagé (même entre Mac et iOS qui partagent le même langage car les spécificité sont trop grande pour que la réutilisation du code puisse avoir un véritable impact) les temps de développement sont relativement ??? <!-- TODO: indiquer les comparaison -->

<!-- TODO: estimer les temps pour l'hypothèse1 -->

#### Hypothèse 1 - **Critère 1.2** : Les limitations des technologies

Ces cinq applications ont donc comme principe d'être chacune native et donc par définition d'avoir un accès à toutes les fonctionnalités offertes par le système d'exploitation cible, et cela sans charge supplémentaire de travail.\
Certains systèmes d'exploitation ajoutent d'ailleurs à cela une couche de sécurité supplémentaire comme Android qui demande la permission à l'utilisateur avant d'accéder à des fonctionnalités natives.

Parmi ces fonctionnalités, on retrouve fréquemment :

- Le stockage de fichiers
- L'accès à Internet
- L'accès aux informations de l'appareil (Marque, numéro de téléphone, composants etc.)
- L'accès aux périphériques de l'appareil (caméra, microphone, GPS etc.)

Afin de juger des libertés d'accès de tous ces logiciels, nous leur donneront une note arbitraire qui s'étend de 0 (aucun accès aux fonctionnalités natives) à 5 (libre accès à toutes les fonctionnalités).

| Système d'exploitation | Langage | Nature | Note sur 5 |
| ---------------------- | ------- | ------ | ---------: |
| Linux                  | Rust    | Natif  | 5.0        |
| Windows                | C#      | Natif  | 5.0        |
| macOS                  | Swift   | Natif  | 5.0        |
| Android                | Kotlin  | Natif  | 4.5        |
| iOS                    | Swift   | Natif  | 4.5        |
| **Moyenne**            |         |        | **4.8**    |

Sans surprise, chaque application reçoit une note proche de maximale étant donné le degré de liberté offert par les applications natives.\
Il est à noté que si Android et iOS ont tout deux des notes légèrement plus basse, c'est en raison de la requête faite à l'utilisateur d'accéder aux fonctionnalités. Quand bien même cette notion est très bénéfique d'un point de vue de la sécurité informatique, nous jugeons ici la degré de liberté d'accès exclusivement.

### Hypothèse 1 - **Critères 2** : Après le développement

#### Hypothèse 1 - **Critères 2.1** : Le déploiement

Nous allons réitérer la méthode de la notation afin de juger la facilité et la rapidité d'un déploiement sur ces différents systèmes d'exploitation.

| Système d'exploitation | Note sur 5 |
| ---------------------- | ---------: |
| Linux                  | 5.0        |
| Windows                | 4.0        |
| macOS                  | 5.0        |
| Android                | 5.0        |
| iOS                    | 2.0        |
| **Moyenne**            | **4.2**    |

Dans le cas de Linux, macOS, Windows Android, il est possible de créer des fichiers uniques qui servent de "containers" à l'application et qui, une fois exécutés, installent directement le logiciel.

Linux offre une grande flexibilité ainsi que de nombreux outils pour faciliter le déploiement (*Ansible*, *Rudder* etc.). macOS et Android, tournant tous deux sous un noyau Linux, profitent d'une flexibilité similaire.

Dans le cas de Windows, la présence d'un installeur obligatoire et les verrous mis sur les procédures d'installation peuvent parfois rendre la tâche légèrement plus compliquée.

Enfin, sur iOS, afin de déployer une application, il est impératif de passer par un *store* (Marchés d'applications) même privé afin de rendre disponible le résultat. Chaque applicatif passant sur le store sera aussi testé par des employés d'Apple, ajoutant une charge temporelle supplémentaire.

#### Hypothèse 1 - **Critères 2.2** : La maintenance

La maintenance peut être perçu comme un second déploiement. Nous devons juger de la vitesse et la facilité de l'intervention en cas de mise à jour.

| Système d'exploitation | Note sur 5 |
| ---------------------- | ---------: |
| Linux                  | 4.5        |
| Windows                | 4.5        |
| macOS                  | 4.5        |
| Android                | 5.0        |
| iOS                    | 3.5        |
| **Moyenne**            | **4.4**    |

Chaque système d'exploitation est très réceptif quand à la mise à jour des applications natives. Android et iOS proposent des systèmes intégrés dans leurs *stores* là ou les mises à jours sur les systèmes d'exploitation bureau doivent êtres implémentés manuellement.

Cependant, iOS souffre des même problématiques de phase de test, bridant de ce fait la réactivité d'un déploiement de correctif.

#### Hypothèse 1 - **Critères 2.3** : La réutilisation

Voyons maintenant à quel point le code source utilisé dans ce projet pourrait-être utilisé à nouveau dans un autre projet.\
Voici un apercu de la manière dont le code pourrait être réutilisé :

<div class="mermaid">
graph LR
   subgraph Projet Actuel
      L1[Linux]
      W1[Windows]
      M1[macOS]
      A1[Android]
      I1[iOS]
   end
   subgraph Prochain Projet
      L2[Linux]
      W2[Windows]
      M2[macOS]
      I2[iOS]
      A2[Android]
   end
   Rust((Rust))
   C#((C#))
   SwiftB((Swift Bureau))
   SwiftM((Swift Mobile))
   Kotlin((Kotlin))
   L1 --- Rust --> L2
   W1 --- C# --> W2
   M1 --- SwiftB --> M2
   M1 -.- SwiftB .-> I2
   A1 --- Kotlin --> A2
   I1 --- SwiftM --> I2
   I1 -.- SwiftM .-> M2
</div>

Comme exprimé précédemment, même si les applications macOS et iOS sont développée dans les mêmes langages, tout le code ne peux pas être transposé de l'un à l'autre, seul quelques fonctionnalités très communes et qui ne touchent pas à l'affichage des données le peuvent.

Nous pouvons voir dans ce cas que si l'on quantifie les liens qu'il est possible de faire entre les applications (une flèche vaut 1 point, et 0.5 point pour les flèches partielles), nous obtenons ce tableau :

| Système d'exploitation | Langage | Partageable sur X projets |
| ---------------------- | ------- | ------------------------: |
| Linux                  | Rust    | 1.0                       |
| Windows                | C#      | 1.0                       |
| macOS                  | Swift   | 1.5                       |
| Android                | Kotlin  | 1.0                       |
| iOS                    | Swift   | 1.5                       |
| **Moyenne**            |         | **1.2**                   |

Attention, dans ce cas précis, les valeurs ne sont pas des notes sur 5 mais bien des ratios que nous pourront comparer plus tard. Actuellement, la moyenne de **1.2** représente un taux de partage de code assez faible puisque le code d'un logiciel n'est réutilisable que pour un logiciel d'un langage identique.

Afin de donner un pourcentage de réutilisation du code, nous pouvons diviser la moyenne obtenue par le nombre de projets. Ce faisant nous obtenons un indice de **24%** de code réutilisable.

### Hypothèse 1 - **Critères 3** : Le résultat

<!-- TODO: mesurer -->

#### Hypothèse 1 - **Critères 3.1** : Utilisation du processeur et de la mémoire

#### Hypothèse 1 - **Critères 3.2** : Temps de réponse moyen

#### Hypothèse 1 - **Critère 3.3** : Le poids de l'exécutable

### Hypothèse 1 - Synthèse des critères

- Critères 1 (Avant le développement)
  - Critère 1.1 (Temps de développement) : ??h
  - Critère 1.2 (Limitations) : 4.8 pts
- Critères 2 (Après le développement)
  - Critère 2.1 (Déploiement) : 4.2 pts
  - Critère 2.2 (Maintenance) : 4.4 pts
  - Critère 2.3 (Réutilisation) : 24%
- Critères 3 (Résultat)
  - Critère 3.1 (*Benchmark*) : ??
  - Critère 3.2 (Temps de réponse) : ??ms
  - Critère 3.3 (Poids total) : ??Mb

### Hypothèse 1 - Conclusion

<!-- TODO: conclusion hypothèse 1 -->

## Hypothèse 2
<!-- TODO: Hypothèse 2 -->

> Séparer les cibles en deux grands groupes, à savoir "Logiciels Bureaux" et "Applications Mobiles" et faire deux applications natives différentes pour ces groupes.

### Hypothèse 2 - Présentation du *proof of concept*

Cette hypothèse reprend en partie le principe de l'hypothèse précédente qui décrivait les applications natives comme étants les alternatives les plus puissantes disponibles. Cependant, pour palier le nombre conséquent d'applications à développer, ce nombre est réduit au plus faible possible en cherchant des technologies capables de créer des logiciels pour les interfaces bureau et d'autres pour les interfaces mobiles.

Conserver les avantages des applications native en limitant grandement le nombre de logiciels semble être une approche prometteuse et pour le démontrer nous réaliserons une application pour chaque groupe d'appareils cibles :

- Logiciels bureau (Linux, Windows, Mac) : [**Kotlin/Java** avec Spring](https://github.com/gothinkster/kotlin-spring-realworld-example-app)
- Logiciels mobile (Android, iOS): [**Dart** avec Flutter](https://github.com/UkonnRa/flutter_realworld_app)

### Hypothèse 2 - **Critères 1** : Pendant le développement

#### Hypothèse 2 - **Critère 1.1** : Le temps de développement

Pour ces deux applications voici les temps de développement :

<!-- TODO: mesurer -->

#### Hypothèse 2 - **Critère 1.2** : Les limitations des technologies

Comme pour l'hypothèse précédente, nous allons juger les deux applications sur la liberté qu'elles offrent aux développeurs d'accéder aux fonctionnalités du système d'exploitation cible.

| Groupe de cibles | Langage | Nature | Note sur 5 |
| ---------------- | ------- | ------ | ---------: |
| Logiciel Bureau  | Kotlin  | Natif  | 5.0        |
| Logiciel Mobile  | Dart    | Natif  | 4.5        |
| **Moyenne**      |         |        | **4.8**    |

Comme nous pouvons le constater, de la même manière que l'hypothèse précédente, les applications natives n'ont que très peu de limitations quand aux fonctionnalités auxquelles elles ont accès.\
Seul l'application mobile possède un léger inconvénient encore une fois, celui  de devoir demander la permission à l'utilisateur pour accéder à certains mécanismes.

### Hypothèse 2 - **Critères 2** : Après le développement

#### Hypothèse 2 - **Critères 2.1** : Le déploiement

Du point de vue de la facilité de déploiement, on peux encore une fois s'attendre à des résultats similaires. Ici nous noteront chaque système d'exploitation à part car, contrairement au langage de développement qui est le même pour chaque cibles d'un groupe, le déploiement doit se faire indépendamment.

| Système d'exploitation | Note sur 5 |
| ---------------------- | ---------: |
| Linux                  | 4.5        |
| Windows                | 4.5        |
| macOS                  | 4.5        |
| Android                | 5.0        |
| iOS                    | 2.0        |
| **Moyenne**            | **4.1**    |

Ici pour les cibles mobiles, le résultat est le même que pour l'hypothèse précédente car la méthode de déploiement est exactement la même.\
Pour les cibles bureau, la seule contrainte notable est la présence obligatoire de Java sur les machines. Java est un logiciel qui est déjà présent sur un grand nombre d'appareils d'utilisateurs et dans le cas échéant, l'installation de celui ci est à la fois simple et rapide.

#### Hypothèse 2 - **Critères 2.2** : La maintenance

La maintenance de ces deux applications est encore une fois similaire à ce qui a été mesuré précédemment.

| Système d'exploitation | Note sur 5 |
| ---------------------- | ---------: |
| Linux                  | 4.5        |
| Windows                | 4.5        |
| macOS                  | 4.5        |
| Android                | 5.0        |
| iOS                    | 3.5        |
| **Moyenne**            | **4.4**    |

Ici, c'est encore les cibles mobiles qui ont l'ascendant sur les cibles fixe en raison de la présence d'un *store* capable de mettre automatiquement les applications à jour sur la machine des utilisateurs.

#### Hypothèse 2 - **Critères 2.3** : La réutilisation

Observons maintenant la capacité du code source à être réutilisé pour un projet aux technologies similaires.

<div class="mermaid">
graph LR
   subgraph Projet Actuel
      subgraph LB1[Logiciel Bureau]
         L1[Linux]
         W1[Windows]
         M1[macOS]
      end
      subgraph LM1[Logiciel Mobile]
         A1[Android]
         I1[iOS]
      end
   end
   subgraph Projet Actuel
      subgraph LB2[Logiciel Bureau]
         L2[Linux]
         W2[Windows]
         M2[macOS]
      end
      subgraph LM2[Logiciel Mobile]
         A2[Android]
         I2[iOS]
      end
   end
   Kotlin((Kotlin))
   Dart((Dart))
   L1 & W1 & M1 --- Kotlin --> L2 & W2 & M2
   A1 & I1 --- Dart --> A2 & I2
</div>

Nous allons maintenant estimer pour chaque cible, le nombre de projet où son code source pourra être réutilisé (combien de flèches partent d'une cible à gauche pour arriver à droite)

| Système d'exploitation | Langage | Partageable sur X projets |
| ---------------------- | ------- | ------------------------: |
| Linux                  | Kotlin  | 3.0                       |
| Windows                | Kotlin  | 3.0                       |
| macOS                  | Kotlin  | 3.0                       |
| Android                | Dart    | 2.0                       |
| iOS                    | Dart    | 2.0                       |
| **Moyenne**            |         | **2.6**                   |

Le ratio obtenu au final montre que le code peut-être partagé en moyenne sur plus de la moitié des projets. Rappelons que le moins bon ratio possible est lorsqu'un projet ne peut-être partagé uniquement vers un projet du même type, donnant ainsi une moyenne de 1 projet. Là ou le meilleur ratio possible serait une solution où chacun des cinq projet peut-être partagé avec les cinq autres, la moyenne serait donc 5.

En divisant ce ratio par la quantité totale des projets nous obtenu un indice de partage de code de **52%** soit plus du double de l'hypothèse précédente.

### Hypothèse 2 - **Critères 3** : Le résultat

#### Hypothèse 2 - **Critères 3.1** : Utilisation du processeur et de la mémoire

#### Hypothèse 2 - **Critères 3.2** : Temps de réponse moyen

#### Hypothèse 2 - **Critère 3.3** : Le poids de l'exécutable

### Hypothèse 2 - Synthèse des critères

- Critères 1 (Avant le développement)
  - Critère 1.1 (Temps de développement) : ??h
  - Critère 1.2 (Limitations) : 4.8 pts
- Critères 2 (Après le développement)
  - Critère 2.1 (Déploiement) : 4.1 pts
  - Critère 2.2 (Maintenance) : 4.4 pts
  - Critère 2.3 (Réutilisation) : 52%
- Critères 3 (Résultat)
  - Critère 3.1 (*Benchmark*) : ??
  - Critère 3.2 (Temps de réponse) : ??ms
  - Critère 3.3 (Poids total) : ??Mb

### Hypothèse 2 - Conclusion

## Hypothèse 3

> Une seule application web et une interface *responsive* pour tout les appareils cibles.

### Hypothèse 3 - Présentation du *proof of concept*

Cette hypothèse part du principe qu'étant donné que toutes les cibles sont munies d'un navigateur internet, il est possible de faire tourner la même application web sur toutes celles ci avec un seul code source et une seule interface qui s'adapterais à l'écran quelque soit sa taille ou sa forme.

Voici l'unique projet donc, qui sera réalisé pour ce *proof of concept* :

[*Typescript/Javascript* avec Angular](https://github.com/gothinkster/angular-realworld-example-app)

### Hypothèse 3 - **Critères 1** : Pendant le développement

#### Hypothèse 3 - **Critère 1.1** : Le temps de développement

<!-- TODO: mesurer le temps -->

#### Hypothèse 3 - **Critère 1.2** : Les limitations des technologies

Pour notre première hypothèse utilisant une technologie du web, voyons quelles sont les limitations de celles ci.

A l'inverse des applications native, les applications web ne possèdent pas un accès direct au fonctionnalités du système d'exploitation. Les seules choses qui leurs sont permises sont les capacités du navigateur dans lequel elles tournent (Accéder à la caméra, la localisation, au microphone par exemple).

Impossible par exemple pour un applicatif web de stocker des fichiers à volonté sur le système de l'utilisateur, même avec sa permission (Et encore là, il faudrait que l'utilisateur accepte chaque stockage de fichier indépendamment).\
Impossible aussi de fonctionner sans une connexion internet décente et régulière ou de exécuter en arrière plan.

Les applications web sont donc très limitées dans ce qu'elle sont capable de faire même si elle possèdent tout de même les qualités requises pour en faire de véritable utilitaires (Affichage et traitement de données).

Pour ce critère, nous évaluons sa note quinaire à **2.5**.

### Hypothèse 3 - **Critères 2** : Après le développement

#### Hypothèse 3 - **Critères 2.1** : Le déploiement

Déployer une application web consiste à mettre son code "compilé" sur un serveur en ligne afin que les utilisateurs puissent le télécharger et l'exécuter directement dans leurs navigateurs internet en indiquant l'adresse url correcte.

Sans action nécessaire de la part de l'utilisateur autre que de cliquer sur le bon lien, on estime le déploiement d'un applicatif web très simple et rapide.

Il est bon à noter aussi que cette méthode de déploiement est la même pour toutes les technologies du web.

Pour ce critère, nous évaluons sa note quinaire à **5.0**.

#### Hypothèse 3 - **Critères 2.2** : La maintenance

La maintenance d'une application web est à la fois simple et délicate.

En effet, même si la maintenance consiste à mettre à jour les fichiers de l'application sur le serveur afin que les utilisateurs puissent récupérer la nouvelle version sans même le savoir, il existe quelques problématique inhérentes aux limitations techniques des technologies du web.

Puisqu'il n'est pas possible de faire fonctionner un logiciel web sans connexion internet, il n'est pas possible de rendre le serveur indisponible le temps de la mise à jour sans mettre en place un système complexe d'équilibreur de charge (*load balancer*, exemple : NGINX).

Pour ce critère, nous évaluons sa note quinaire à **3.0**.

#### Hypothèse 3 - **Critères 2.3** : La réutilisation

Du point de vue de la réutilisation du code, étant donné que ce projet se base sur une technologie unique par rapport aux précédentes hypothèse, nous pouvons d'ors et déjà fixer l'indice de réutilisation à **100%**.

### Hypothèse 3 - **Critères 3** : Le résultat

#### Hypothèse 3 - **Critères 3.1** : Utilisation du processeur et de la mémoire

#### Hypothèse 3 - **Critères 3.2** : Temps de réponse moyen

#### Hypothèse 3 - **Critère 3.3** : Le poids de l'exécutable

### Hypothèse 3 - Synthèse des critères

- Critères 1 (Avant le développement)
  - Critère 1.1 (Temps de développement) : ??h
  - Critère 1.2 (Limitations) : 2.5 pts
- Critères 2 (Après le développement)
  - Critère 2.1 (Déploiement) : 5 pts
  - Critère 2.2 (Maintenance) : 3 pts
  - Critère 2.3 (Réutilisation) : 100%
- Critères 3 (Résultat)
  - Critère 3.1 (*Benchmark*) : ??
  - Critère 3.2 (Temps de réponse) : ??ms
  - Critère 3.3 (Poids total) : ??Mb

### Hypothèse 3 - Conclusion

## Hypothèse 4

> Une application web pour les cibles bureau et une application native dans le même langage pour le cibles mobiles

### Hypothèse 4 - Présentation du *proof of concept*

Cette hypothèse s'aligne sur la vision de la deuxième en affirmant que deux applications différentes pour les deux types de cibles permet de limiter les temps de développement.\
A l'inverse de cette dernière cependant, l'hypothèse 4 est basée sur un langage unique dont les blocs qui la compose peuvent être réemployé.

Voici les deux projets qui composent cette hypothèse :

- Logiciel Bureau (Linux, Windows, Mac) : [**Typescript/Javascript** avec Angular](https://github.com/gothinkster/angular-realworld-example-app)
- Logiciel Mobile (Android, iOS): [**Typescript/Javascript** avec NativeScript et Angular](https://github.com/nea/nativescript-realworld-example-app)

Ils se reposent tout deux sur le même langage (*Typescript*) et le même outil de conception (*Angular*). L'application mobile utilise en plus l'outil *NativeScript* qui permet de transformer un projet web utilisant *Angular* en application mobile native pour Android et iOS.

### Hypothèse 4 - **Critères 1** : Pendant le développement

#### Hypothèse 4 - **Critère 1.1** : Le temps de développement

<!-- TODO: mesurer -->

#### Hypothèse 4 - **Critère 1.2** : Les limitations des technologies

Dans le cas d'une application web et une autre native, nous pouvons nous attendre à des différences assez importantes après les observations que nous avons pu effectuer lors de l'analyse des hypothèses précédentes.

| Groupe de cibles | Langage    | Nature | Note sur 5 |
| ---------------- | ---------- | ------ | ---------: |
| Logiciel Bureau  | Typescript | Web    | 2.5        |
| Logiciel Mobile  | Typescript | Natif  | 4.5        |
| **Moyenne**      |            |        | **3.5**    |

En effet, tel que dans l'hypothèse précédente, les applications web n'ont que très peu de libertés quand aux fonctionnalités auxquelles elles ont accès là ou, tel que dans les hypothèses 1 et 2, ce n'est pas un problème que rencontre les logiciels natifs.

### Hypothèse 4 - **Critères 2** : Après le développement

#### Hypothèse 4 - **Critères 2.1** : Le déploiement

Même chose dans le cas du déploiement, nous pouvons nous attendre à des notes similaire que pour les hypothèses web et native.

| Système d'exploitation | Note sur 5 |
| ---------------------- | ---------: |
| Linux                  | 5.0        |
| Windows                | 5.0        |
| macOS                  | 5.0        |
| Android                | 4.5        |
| iOS                    | 2.0        |
| **Moyenne**            | **4.3**    |

Le déploiement de l'application web reste aussi simple que dans l'hypothèse précédente, et nous rencontrons les mêmes problématiques pour le déploiement sur les mobiles iOS que sur les autres hypothèses.

#### Hypothèse 4 - **Critères 2.2** : La maintenance

Idem pour la maintenance.

| Système d'exploitation | Note sur 5 |
| ---------------------- | ---------: |
| Linux                  | 3.0        |
| Windows                | 3.0        |
| macOS                  | 3.0        |
| Android                | 5.0        |
| iOS                    | 3.5        |
| **Moyenne**            | **3.5**    |

Ici encore, seul Android et son store qui permet les mises à jours automatique parvient à se démarquer des applications webs et leur maintenance coûteuse ou de iOS et de sa phase de test obligatoire bridant la réactivité des déploiements.

#### Hypothèse 4 - **Critères 2.3** : La réutilisation

Jugeons de la capacité du code à pouvoir servir à nouveau lors du développement d'un projet usant de technologies semblables.

<div class="mermaid">
graph LR
   subgraph Projet Actuel
      subgraph LB1[Logiciel Bureau]
         L1[Linux]
         W1[Windows]
         M1[macOS]
      end
      subgraph LM1[Logiciel Mobile]
         A1[Android]
         I1[iOS]
      end
   end
   subgraph Projet Actuel
      subgraph LB2[Logiciel Bureau]
         L2[Linux]
         W2[Windows]
         M2[macOS]
      end
      subgraph LM2[Logiciel Mobile]
         A2[Android]
         I2[iOS]
      end
   end
   TS((Typescript))
   L1 & W1 & M1 & A1 & I1 --- TS --> L2 & W2 & M2 & A2 & I2
</div>

Ici, pour simplifier le schéma nous ne voyons que les liens directs qui se font.
Voyons plus en détails les liens effectifs :

| Système d'exploitation | Langage    | Nature | Partageable sur X projets |
| ---------------------- | ---------- | ------ | ------------------------: |
| Linux                  | Typescript | Web    | 4                         |
| Windows                | Typescript | Web    | 4                         |
| macOS                  | Typescript | Web    | 4                         |
| Android                | Typescript | Natif  | 3.5                       |
| iOS                    | Typescript | Natif  | 3.5                       |
| **Moyenne**            |            |        | **3.8**                   |

On considère que le code du web peut être partagé sur les trois système d'exploitation bureau (soit 3) et que seul la moitié du code est réutilisable sur les cibles mobiles (soit 0.5 *2 = 1). \
De même, ce calcul inversé pour les cibles mobiles nous indique qu'il peut être partagé sur les deux système d'exploitation mobiles (soit 2) et uniquement partiellement sur les cibles bureau (soit 0.5* 3 = 1.5).

En divisant le ratio moyen par la quantité totale des projets nous obtenu un indice de partage de code de **76%**. Cela reste moins que pour l'hypothèse 3 exclusivement web et mono-projet mais bien au delà des résultats obtenus pour les applications natives.

### Hypothèse 4 - **Critères 3** : Le résultat

#### Hypothèse 4 - **Critères 3.1** : Utilisation du processeur et de la mémoire

#### Hypothèse 4 - **Critères 3.2** : Temps de réponse moyen

#### Hypothèse 4 - **Critère 3.3** : Le poids de l'exécutable

### Hypothèse 4 - Synthèse des critères

- Critères 1 (Avant le développement)
  - Critère 1.1 (Temps de développement) : ??h
  - Critère 1.2 (Limitations) : 3.5 pts
- Critères 2 (Après le développement)
  - Critère 2.1 (Déploiement) : 4.3 pts
  - Critère 2.2 (Maintenance) : 3.5 pts
  - Critère 2.3 (Réutilisation) : 76%
- Critères 3 (Résultat)
  - Critère 3.1 (*Benchmark*) : ??
  - Critère 3.2 (Temps de réponse) : ??ms
  - Critère 3.3 (Poids total) : ??Mb

### Hypothèse 4 - Conclusion

## Hypothèse 5
<!-- TODO: Hypothèse 5 -->

> Une application web hybride pour les cibles bureau et une application hybride pour les cibles mobiles

### Hypothèse 5 - Présentation du *proof of concept*

Cette hypothèse reprend en quelque sorte le format de l'hypothèse 2 et les technologies de l'hypothèse 3 à savoir réaliser deux applicatifs différents dans des technologies du web. Il ajoute en plus le fait de profiter de cette différence pour en faire des applications hybrides.\
Cette hypothèse cherche à palier le manque d'accès aux fonctionnalités du système d'exploitation en encapsulant l'application web dans un logiciel natif (ayant ces accès) et de faire communiquer les deux.

Les technologies que nous utiliseront dans cette hypothèse seront les mêmes que celles de l'hypothèse précédentes, à cela prêt que les applications seront modifiées afin d'utiliser des technologies de création d'applications hybride.

Ces technologies capable de faire d'une application web, une application hybrides sont :

- Pour le logiciel bureau : [Electron](https://www.electronjs.org/)
- Pour le logiciel mobile : [Cordova](https://cordova.apache.org/)

### Hypothèse 5 - **Critères 1** : Pendant le développement

#### Hypothèse 5 - **Critère 1.1** : Le temps de développement

<!-- TODO: mesurer -->

#### Hypothèse 5 - **Critère 1.2** : Les limitations des technologies

Tout l'intérêt de cette hypothèse repose sur le principe de développer avec des technologies web et de profiter des conteneurs natifs pour pouvoir accéder aux fonctionnalités des systèmes d'exploitations des appareils cibles.

| Groupe de cibles | Langage    | Nature  | Note sur 5 |
| ---------------- | ---------- | ------- | ---------: |
| Logiciel Bureau  | Typescript | Hybride | 4.5        |
| Logiciel Mobile  | Typescript | Hybride | 4.0        |
| **Moyenne**      |            |         | **4.3**    |

L'accès aux fonctionnalités natives se fait dans ces technologies hybrides, par la mise en place de *plugins*, permettant l'accès à chacune des fonctionnalités une par une. C'est un coût de temps de développement certes très léger, mais présent par rapport à une application native.

Par ailleurs, les applications mobiles "souffrent" aussi toujours de la demande de confirmation à l'utilisateur lors de l'accès aux fonctionnalités.

### Hypothèse 5 - **Critères 2** : Après le développement

#### Hypothèse 5 - **Critères 2.1** : Le déploiement

Le déploiement de ces deux applicatifs est similaire à celle des applications native puisque que les systèmes d'exploitation ne sont pas capable de faire la différence entre un logiciel hybride et natif.

| Système d'exploitation | Note sur 5 |
| ---------------------- | ---------: |
| Linux                  | 4.5        |
| Windows                | 4.5        |
| macOS                  | 4.5        |
| Android                | 5.0        |
| iOS                    | 2.0        |
| **Moyenne**            | **4.1**    |

Les résultats sont donc les même que pour l'hypothèse 2.

#### Hypothèse 5 - **Critères 2.2** : La maintenance

Idem pour la maintenance.

| Système d'exploitation | Note sur 5 |
| ---------------------- | ---------: |
| Linux                  | 4.5        |
| Windows                | 4.5        |
| macOS                  | 4.5        |
| Android                | 5.0        |
| iOS                    | 3.5        |
| **Moyenne**            | **4.4**    |

#### Hypothèse 5 - **Critères 2.3** : La réutilisation

Cependant, contrairement à l'hypothèse 2, l'utilisation de la technologie web est là pour optimiser grandement la réutilisation possible du code source.
Mise à part l'interface qui peut être différente, l'intégralité de ce code peut être réutilisé à volonté dans des projets ultérieurs.

Les applications hybrides bénéficient donc d'un indice de réutilisation du code de **100%** comme les applications web (cf. hypothèse 3).

### Hypothèse 5 - **Critères 3** : Le résultat

#### Hypothèse 5 - **Critères 3.1** : Utilisation du processeur et de la mémoire

#### Hypothèse 5 - **Critères 3.2** : Temps de réponse moyen

#### Hypothèse 5 - **Critère 3.3** : Le poids de l'exécutable

### Hypothèse 5 - Synthèse des critères

- Critères 1 (Avant le développement)
  - Critère 1.1 (Temps de développement) : ??h
  - Critère 1.2 (Limitations) : 4.3 pts
- Critères 2 (Après le développement)
  - Critère 2.1 (Déploiement) : 4.1 pts
  - Critère 2.2 (Maintenance) : 4.4 pts
  - Critère 2.3 (Réutilisation) : 100%
- Critères 3 (Résultat)
  - Critère 3.1 (*Benchmark*) : ??
  - Critère 3.2 (Temps de réponse) : ??ms
  - Critère 3.3 (Poids total) : ??Mb

### Hypothèse 5 - Conclusion
