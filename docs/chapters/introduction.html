<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Introduction | Thèse professionnelle</title>
<meta name="generator" content="Jekyll v4.0.1" />
<meta property="og:title" content="Introduction" />
<meta name="author" content="Quentin Widlocher" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Objet de la thèse Contexte Problématique Cibles visées Hypothèses proposées Première hypothèse Deuxième hypothèse Troisième hypothèse Quatrième hypothèse Cinquième hypothèse Démarche proposée Qu’est ce qu’un proof of concept Les critères Critères 1 : Pendant le développement Critère 1.1 : Le temps de développement Critère 1.2 : Les limitations des technologies Critères 2 : Après le développement Critères 2.1 : Le déploiement Critères 2.2 : La maintenance Critères 2.3 : La réutilisation Critères 3 : Le résultat Critère 3.1 : Utilisation du processeur et de la mémoire Critère 3.2 : Temps de réponse moyen Critère 3.3 : Le poids de l’exécutable Comparaisons des critères entres eux RealWorld Conduit Les fonctionnalités Visuels application bureau Visuels application mobile Précisions sur les mesures Valeur ajoutée de cette recherche" />
<meta property="og:description" content="Objet de la thèse Contexte Problématique Cibles visées Hypothèses proposées Première hypothèse Deuxième hypothèse Troisième hypothèse Quatrième hypothèse Cinquième hypothèse Démarche proposée Qu’est ce qu’un proof of concept Les critères Critères 1 : Pendant le développement Critère 1.1 : Le temps de développement Critère 1.2 : Les limitations des technologies Critères 2 : Après le développement Critères 2.1 : Le déploiement Critères 2.2 : La maintenance Critères 2.3 : La réutilisation Critères 3 : Le résultat Critère 3.1 : Utilisation du processeur et de la mémoire Critère 3.2 : Temps de réponse moyen Critère 3.3 : Le poids de l’exécutable Comparaisons des critères entres eux RealWorld Conduit Les fonctionnalités Visuels application bureau Visuels application mobile Précisions sur les mesures Valeur ajoutée de cette recherche" />
<meta property="og:site_name" content="Thèse professionnelle" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-11-08T19:00:19+00:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","url":"/ThesePro/chapters/introduction","headline":"Introduction","dateModified":"2020-11-08T19:00:19+00:00","datePublished":"2020-11-08T19:00:19+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"/ThesePro/chapters/introduction"},"author":{"@type":"Person","name":"Quentin Widlocher"},"description":"Objet de la thèse Contexte Problématique Cibles visées Hypothèses proposées Première hypothèse Deuxième hypothèse Troisième hypothèse Quatrième hypothèse Cinquième hypothèse Démarche proposée Qu’est ce qu’un proof of concept Les critères Critères 1 : Pendant le développement Critère 1.1 : Le temps de développement Critère 1.2 : Les limitations des technologies Critères 2 : Après le développement Critères 2.1 : Le déploiement Critères 2.2 : La maintenance Critères 2.3 : La réutilisation Critères 3 : Le résultat Critère 3.1 : Utilisation du processeur et de la mémoire Critère 3.2 : Temps de réponse moyen Critère 3.3 : Le poids de l’exécutable Comparaisons des critères entres eux RealWorld Conduit Les fonctionnalités Visuels application bureau Visuels application mobile Précisions sur les mesures Valeur ajoutée de cette recherche","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/ThesePro/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/ThesePro/feed.xml" title="Thèse professionnelle" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/ThesePro/">Thèse professionnelle</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <h1>Introduction</h1>
<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
    <div class="post-content e-content" itemprop="articleBody">
        <ol>
  <li><a href="#objet-de-la-thèse">Objet de la thèse</a></li>
  <li><a href="#contexte">Contexte</a></li>
  <li><a href="#problématique">Problématique</a></li>
  <li><a href="#cibles-visées">Cibles visées</a></li>
  <li><a href="#hypothèses-proposées">Hypothèses proposées</a>
    <ol>
      <li><a href="#première-hypothèse">Première hypothèse</a></li>
      <li><a href="#deuxième-hypothèse">Deuxième hypothèse</a></li>
      <li><a href="#troisième-hypothèse">Troisième hypothèse</a></li>
      <li><a href="#quatrième-hypothèse">Quatrième hypothèse</a></li>
      <li><a href="#cinquième-hypothèse">Cinquième hypothèse</a></li>
    </ol>
  </li>
  <li><a href="#démarche-proposée">Démarche proposée</a>
    <ol>
      <li><a href="#quest-ce-quun-proof-of-concept">Qu’est ce qu’un <em>proof of concept</em></a></li>
      <li><a href="#les-critères">Les critères</a>
        <ol>
          <li><a href="#critères-1--pendant-le-développement"><strong>Critères 1</strong> : Pendant le développement</a>
            <ol>
              <li><a href="#critère-11--le-temps-de-développement"><strong>Critère 1.1</strong> : Le temps de développement</a></li>
              <li><a href="#critère-12--les-limitations-des-technologies"><strong>Critère 1.2</strong> : Les limitations des technologies</a></li>
            </ol>
          </li>
          <li><a href="#critères-2--après-le-développement"><strong>Critères 2</strong> : Après le développement</a>
            <ol>
              <li><a href="#critères-21--le-déploiement"><strong>Critères 2.1</strong> : Le déploiement</a></li>
              <li><a href="#critères-22--la-maintenance"><strong>Critères 2.2</strong> : La maintenance</a></li>
              <li><a href="#critères-23--la-réutilisation"><strong>Critères 2.3</strong> : La réutilisation</a></li>
            </ol>
          </li>
          <li><a href="#critères-3--le-résultat"><strong>Critères 3</strong> : Le résultat</a>
            <ol>
              <li><a href="#critère-31--utilisation-du-processeur-et-de-la-mémoire"><strong>Critère 3.1</strong> : Utilisation du processeur et de la mémoire</a></li>
              <li><a href="#critère-32--temps-de-réponse-moyen"><strong>Critère 3.2</strong> : Temps de réponse moyen</a></li>
              <li><a href="#critère-33--le-poids-de-lexécutable"><strong>Critère 3.3</strong> : Le poids de l’exécutable</a></li>
            </ol>
          </li>
          <li><a href="#comparaisons-des-critères-entres-eux">Comparaisons des critères entres eux</a></li>
        </ol>
      </li>
      <li><a href="#realworld">RealWorld</a>
        <ol>
          <li><a href="#conduit">Conduit</a>
            <ol>
              <li><a href="#les-fonctionnalités">Les fonctionnalités</a></li>
              <li><a href="#visuels-application-bureau">Visuels application bureau</a></li>
              <li><a href="#visuels-application-mobile">Visuels application mobile</a></li>
            </ol>
          </li>
        </ol>
      </li>
      <li><a href="#précisions-sur-les-mesures">Précisions sur les mesures</a></li>
    </ol>
  </li>
  <li><a href="#valeur-ajoutée-de-cette-recherche">Valeur ajoutée de cette recherche</a></li>
</ol>

<h2 id="objet-de-la-thèse">Objet de la thèse</h2>

<p>Cette thèse professionnelle s’inscrit dans une volonté d’éclaircir des points de détails qui, au sein d’un environnement de travail axé sur le développement de logiciels informatiques, sont trop souvent mal compris, mal interprétés, voire tout à fait mis de côtés.<br />
Si ces obstacles sont victimes de ce traitement, ce n’est pas en raison de leurs complexités mais bien devant la charge de travail requise afin de déceler leurs subtilités. C’est ce problème que je m’engage à adresser dans cette thèse.</p>

<p>Son but est de chercher à analyser le sujet en profondeur et de proposer des pistes de résolution à une préoccupation majeure des entreprises de ce secteur. Nous verrons aussi d’où vient cette problématique et s’il est juste de chercher à la résoudre plutôt que de la contourner si cela est possible.</p>

<h2 id="contexte">Contexte</h2>

<p>Lorsque j’écris cette thèse, je suis actuellement en poste dans une entreprise de développement de logiciels sur mesure. Je suis donc un développeur comme plus de vingt-six millions de personnes dans le monde<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote">1</a></sup>, et comme eux, je suis sans cesse à la recherche <strong>d’optimisation</strong>.<br />
Le désir constant d’optimisation peut-être perçu comme la lutte continuelle pour l’amélioration d’un fonctionnement, pour la minimisation des contraintes et des coûts pour mener à bien une activité.</p>

<p>Dans mon (notre) cas de figure, au sein de sociétés dont le but est de fournir à ses clients des logiciels capables de répondre à leurs besoins les plus directs, cette optimisation est bien entendu fondamentale. Limiter le temps de réponse de l’entreprise pour adresser les besoins du client, qui lui même demande une solution informatiques très souvent dans l’optique d’optimiser son temps de production ou de réponse.<br />
Le temps n’est d’ailleurs bien souvent pas la seule contrainte que l’on cherche à optimiser, le budget est aussi très sollicité aussi. De toute manière, il n’y a pas de contrainte que l’on ne désirerais pas réduire à zéro.</p>

<p>Le métier de développeur est en cela le plus à même d’amener des pistes de réflexion sur l’optimisation étant donné la nature même du travail. Les ingénieurs logiciels font de la résolution de problèmes et de la vitesse ainsi que de l’efficacité de ces résolutions un enjeu premier.<br />
Dans un cœur de métier aussi technique, il est donc normal d’avoir une multitude d’outils dont le but premier est la minimisation des coûts et des obstacles, et la maximisation de la qualité du résultat.</p>

<p>Il existe un principe de programmation très employé qui cristallise un facette de l’optimisation, à savoir le principe <em>DRY</em>.<br />
<em>DRY</em>, pour <em>Don’t Repeat Yourself</em>, soit littéralement “Ne vous répétez pas” est un rappel constant aux développeurs de ne pas ré-écrire ce qui a déjà été écrit auparavant. Souvent entend on “Si vous devez écrire plus de deux fois la même chose, c’est que vous pouvez mieux faire”, ou pour reprendre les mots de Andy Hunt et Dave Thomas<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote">2</a></sup>, initiateurs du principe <em>DRY</em> :</p>

<blockquote>
  <p>Dans un système, toute connaissance doit avoir une représentation unique, non-ambiguë, faisant autorité.</p>
</blockquote>

<h2 id="problématique">Problématique</h2>

<p>Parmi les nombreuses raisons de chercher à optimiser et à “ne pas se répéter” lorsque l’on développe une application, il y en a une qui s’avère être depuis bien longtemps particulièrement chronophage et par conséquent, onéreuse.<br />
Pour qu’un logiciel puisse être disponible pour le plus grand nombre, il faut que celui-ci puisse exécuter sur un grand nombre d’appareils tous bien différents. La forme de l’écran, les performances de la machine, la méthode de saisie, tous ces paramètres sont à prendre en compte et il faut parfois redévelopper une application identique à l’aide un autre langage de programmation si l’on veut une version compatible.</p>

<p>Devant cela bien sûr, le principe <em>DRY</em> est violé et, par là même, l’optimisation devient très compliquée.<br />
Nous pouvons donc nous demander :</p>

<blockquote>
  <p>Comment faire le choix d’une architecture applicative multiplateforme ?</p>
</blockquote>

<p>Cette problématique n’est pas seulement à propos de “comment”, dans le sens technique du terme mais aussi de “faut-il” ou même “est il possible”.</p>

<p>En effet si une application peut être développée une seule fois et être compatible avec un grand nombre d’appareils différents, cela peut apporter une grande valeur ajoutée. Mais si ce développement est bien plus complexe et coûteux (en budget mais aussi en temps), l’effort vaut il le coup ?</p>

<p>L’effort lui même, est il envisageable au vu des technologies actuelles ? Existe-t-il un ou plusieurs outils à-même de répondre au besoin de portabilité d’une architecture applicative ? Et quelle serait la difficulté de les mettre en place dans un projet à venir, ou un projet existant ?</p>

<h2 id="cibles-visées">Cibles visées</h2>

<p>Cette question brasse un champ bien trop vague des possibles pour pouvoir en extraire une réponse valable pour tous les appareils informatiques existants.<br />
Aussi nous allons réduire la portée de notre recherche aux systèmes d’exploitation les plus populaires aujourd’hui, chez les particuliers comme chez les professionnels. <!-- TODO: source --></p>

<p>Ces systèmes d’exploitation peuvent être groupés en deux catégories de support physique à savoir les terminaux fixes et mobiles :</p>

<ul>
  <li>Terminaux fixes :
    <ul>
      <li>Linux</li>
      <li>Microsoft Windows (à partir de la version 7<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote">3</a></sup>)</li>
      <li>macOS (OSX)</li>
    </ul>
  </li>
  <li>Terminaux mobiles (smartphones) :
    <ul>
      <li>Android</li>
      <li>iOS</li>
    </ul>
  </li>
</ul>

<p>Ces cinq systèmes d’exploitation seront notre principale préoccupation étant donné qu’ils représentent ensemble plus de ??%<!-- TODO: source --> de l’utilisation de machines informatiques.</p>

<h2 id="hypothèses-proposées">Hypothèses proposées</h2>

<p>Devant cette problématique, nous pouvons émettre plusieurs hypothèses afin de tenter de répondre à la question posée.<br />
Chaque hypothèse propose une piste de réflexion prenant en compte les subtilités techniques ainsi que les risques de chaque technologies.</p>

<h3 id="première-hypothèse">Première hypothèse</h3>

<p>Tout d’abord, afin de partir d’une hypothèse qui semblerait évidente, et qui aura pour but d’être comparée avec d’autres hypothèses plus recherchées, nous pouvons annoncer cette solution potentielle :</p>

<blockquote>
  <p>Une application native pour chaque appareil cible.</p>
</blockquote>

<p>De ce fait, cette hypothèse servira de “témoin” puisqu’elle ne nécessite pas de travaux de recherche particuliers et se contente de l’existant pour répondre à la problématique posée.<br />
C’est en comparant les résultats de cette hypothèse aux autres que nous pourrons déterminer l’utilité de cette recherche de solution, ainsi que le bien fondé de la problématique.</p>

<div class="mermaid">
graph TD
    CS1((Code)) --&gt; UI1(Interface) --&gt;|Application native| MC1[Linux]
    CS2((Code)) --&gt; UI2(Interface) --&gt;|Application native| MC2[Windows]
    CS3((Code)) --&gt; UI3(Interface) --&gt;|Application native| MC3[OSX]
    CS4((Code)) --&gt; UI4(Interface) --&gt;|Application native| MC4[Android]
    CS5((Code)) --&gt; UI5(Interface) --&gt;|Application native| MC5[iOS]
</div>

<blockquote>
  <p>Schéma d’un exemple de cette hypothèse</p>
</blockquote>

<h3 id="deuxième-hypothèse">Deuxième hypothèse</h3>

<blockquote>
  <p>Séparer les cibles en deux grands groupes, à savoir “Logiciels Bureaux” et “Applications Mobiles” et faire deux applications natives différentes pour ces groupes.</p>
</blockquote>

<p>En limitant les applications, le temps de développement se retrouve lui aussi réduit. Si nous nous concentrons sur deux groupes de cibles il n’y a alors que deux codes sources à créer et à maintenir. Leurs deux langages de programmation étant très probablement différents, les fonctionnalités seront donc écrites deux fois mais on peux facilement imaginer que c’est un coût supplémentaire éclipsé par les performances des applications ainsi que leurs possibilités.</p>

<div class="mermaid">
graph TD
    subgraph Mobile
        CS2((Code))
        UI2(Interface)
        MC4[Android]
        MC5[iOS]
        CS2 --&gt; UI2 --&gt;|Application Native| MC4 &amp; MC5
    end
    subgraph Bureau
        CS1((Code))
        UI1(Interface)
        MC1[Linux]
        MC2[Windows]
        MC3[OSX]
        CS1 --&gt; UI1 --&gt;|Application Native| MC1 &amp; MC2 &amp; MC3
    end
</div>

<blockquote>
  <p>Schéma d’un exemple de cette hypothèse</p>
</blockquote>

<h3 id="troisième-hypothèse">Troisième hypothèse</h3>

<blockquote>
  <p>Une seule application web et une interface <em>responsive</em> pour tout les appareils cibles.</p>
</blockquote>

<p>Les applications web peuvent tourner sur n’importe quel appareil doté d’un navigateur internet. Le responsive design permet d’afficher un site sur toute taille d’écran. Il devrait donc être possible d’avoir une seule application web qui puisse être déployée sur une multitude de supports compatible tout en ne gardant qu’un seul code source.<br />
Cette solution potentielle se rapproche de la deuxième hypothèse dans sa limitation des coûts et son optimisation de la quantité du code.</p>

<div class="mermaid">
graph TD
    CS1((Code))
    UI1(Interface)
    MC1[Linux]
    MC2[Windows]
    MC3[OSX]
    MC4[Android]
    MC5[iOS]
    CS1 --&gt; UI1 --&gt;|Application Web| MC1 &amp; MC2 &amp; MC3 &amp; MC4 &amp; MC5
</div>

<h3 id="quatrième-hypothèse">Quatrième hypothèse</h3>

<blockquote>
  <p>Une application web pour les cibles bureau et une application native dans le même langage pour le cibles mobiles</p>
</blockquote>

<p>Cette hypothèse possède une grande similitude avec l’hypothèse précédente, à la différence près que l’application mobile est native.<br />
En effet il existe de plus en plus d’outils permettant au développeurs d’applicatifs web de contraindre certaines de leurs possibilités pour permettre la création d’un logiciel natif à l’aide d’un code source pour logiciels web.</p>

<p>Parmi ces outils on retrouve trois très populaires qui utilisent les trois <a href="/chapters/glossaire#framework"><em>frameworks</em></a> web les plus connus à savoir :</p>

<ul>
  <li><em>React Native</em> pour React</li>
  <li><em>Ionic</em> pour React, Angular et Vue</li>
  <li><em>NativeScript</em> pour Angular et Vue</li>
</ul>

<p>Ces outils permettent de partager une grande quantité de code depuis d’autres projets JavaScript et ne requièrent la modification que de la partie interface utilisateur. Dans le cas où les développeurs font le choix de commencer avec l’un de ces outils, ils peuvent réutiliser 100% du code pour faire une application web sur bureau et native sur mobile.</p>

<div class="mermaid">
graph TD
    CSP(Code Partageable) &lt;--&gt; CS1 &amp; CS2
    subgraph Mobile
      CS1((Code)) --- UI2(Interface)
      MC4[Android]
      MC5[iOS]
      APP1[Application Native]
      UI2 --- APP1  --&gt; MC4 &amp; MC5
    end
    subgraph Bureau
      CS2((Code)) --- UI1(Interface)
      MC1[Linux]
      MC2[Windows]
      MC3[OSX]
      APP2[Application Web]
      UI1 --- APP2 --&gt; MC1 &amp; MC2 &amp; MC3
    end
</div>

<h3 id="cinquième-hypothèse">Cinquième hypothèse</h3>

<blockquote>
  <p>Une application hybride pour les cibles bureau et une application hybride pour les cibles mobiles</p>
</blockquote>

<p>Grâce au langage de programmation commun (JavaScript), il est possible partager un maximum de code entre les deux applications tout en gardant les spécificités de l’affichage sur grand et petit écran. De plus l’application hybride permet d’accéder à plus de fonctionnalités du système d’exploitation et à mieux se fondre dans l’écosystème d’application de l’utilisateur.</p>

<div class="mermaid">
graph TD
    CS1((Code))
    CS1 --- UI1 &amp; UI2
    subgraph Mobile
      UI2(Interface)
      MC4[Android]
      MC5[iOS]
      APP1[Application Hybride]
      UI2 --- APP1  --&gt; MC4 &amp; MC5
    end
    subgraph Bureau
      UI1(Interface)
      MC1[Linux]
      MC2[Windows]
      MC3[OSX]
      APP2[Application Hybride]
      UI1 --- APP2 --&gt; MC1 &amp; MC2 &amp; MC3
    end
</div>

<h2 id="démarche-proposée">Démarche proposée</h2>

<p>Afin de vérifier nos hypothèses et s’assurer du résultats des solutions proposées, nous allons mettre en place une démonstration de faisabilité, souvent appelé par les développeurs un <em>Proof of Concept</em> (littéralement “preuve de concept”).\</p>

<h3 id="quest-ce-quun-proof-of-concept">Qu’est ce qu’un <em>proof of concept</em></h3>

<p>Ces <em>proofs of concept</em> sont de petites démonstrations techniques mêlant plusieurs technologies au sein d’une application dont l’usage se rapproche au plus près possible d’une réelle application “métier”, tout en conservant une portée réduite (démonstration oblige).</p>

<p>Cette méthode permet, lorsque son utilisation est correcte, d’effectuer des mesures sur une panel de critères aussi complet que possible afin de pouvoir confronter les résultats des différentes hypothèses.<br />
Afin que chaque relevé soit aussi assimilable aux autres que possible, il faut que les <em>proof of concept</em> suivent tous des règles communes. Il faut, si possible, que chacun d’eux soient une itération d’une même application, dans des technologies différentes.</p>

<h3 id="les-critères">Les critères</h3>

<p>Les critères de jugement sont multiples et s’appliquent tous à des parties cruciales d’une application réelle.<br />
Nous scinderont ces critères en trois grandes parties afin de simplifier au mieux la lecture et la compréhension.</p>

<p>Il est important de rappeler que nous ne jugeront pas ici des technologies de constructions d’application (<em>frameworks</em>) mais uniquement des langages.</p>

<h4 id="critères-1--pendant-le-développement"><strong>Critères 1</strong> : Pendant le développement</h4>

<p>Ces critères sont des mesures des problématiques encourues lors de la phase de conception d’une application. Ils se rapportent principalement aux développeurs et aux obstacles qui leurs font face tout au long du développement.</p>

<h5 id="critère-11--le-temps-de-développement"><strong>Critère 1.1</strong> : Le temps de développement</h5>

<p>L’un des critères les plus important, tant aux yeux des développeurs qu’à ceux des managers et des responsables, c’est bien entendu le temps qu’une application met à être produite.<br />
Ce temps, mesuré en jours/homme se devra d’être aussi court que possible afin de limiter les coûts salariaux et de répondre au plus vite au besoin client.</p>

<p>Dans le cas de nos <em>proofs of concept</em>, je serais le seul développeur affecté à la réalisation des démonstrations. Le niveau d’aisance dans une technologie ayant un impact non négligeable lors de la réalisation d’un <em>proof of concept</em> malgré la faible portée de ce dernier, mon niveau personnel dans chaque technologie sera à prendre en compte et précisé dans l’analyse des résultats.</p>

<p>Pour mesurer ce critère, nous relèveront le temps passé à developer une démonstration quotidiennement et nous compareront les résultats obtenus.</p>

<h5 id="critère-12--les-limitations-des-technologies"><strong>Critère 1.2</strong> : Les limitations des technologies</h5>

<p>Une application native possède, par définition, un accès complet aux fonctionnalités qu’offre le système d’exploitation sur lequel il exécute, sous réserve qu’il possède les droits nécessaires.<br />
Une application web en revanche n’a pas ces accès et souvent il existe certaines fonctionnalités inaccessibles qui brident ce qu’il est possible de faire pour l’utilisateur.</p>

<p>Ces limitations peuvent se révéler cruciales pour une application métier et même s’il est souvent possible pour les développeurs de les contourner, il faut tout de même prendre cela en compte lors du comparatifs des solutions.</p>

<p>Les limitations peuvent aussi se faire sentir du point de vue du design global de l’application. Le design, bien qu’étant souvent perçu comme étant non obligatoire et parfois même superflu, peut s’avérer très important dans le cas de certains projet visant à créer une application agréable d’utilisation.<br />
Pour en juger, nous considèreront les possibilités offertes par la technologie employée pour permettre une grande liberté esthétique.</p>

<p>Pour mesurer ce critère, nous utiliseront un système de note arbitraire en fonction de différents sous-critères liés à celui ci.</p>

<h4 id="critères-2--après-le-développement"><strong>Critères 2</strong> : Après le développement</h4>

<p>Ces critères se rapportent eux, à ce qui se passe une fois qu’une application est développée, qu’elle soit finie ou non. Nous allons donc nous intéresser à la livraison du produit, sa maintenance et l’optimisation des ressources en cas de réutilisation du code.</p>

<h5 id="critères-21--le-déploiement"><strong>Critères 2.1</strong> : Le déploiement</h5>

<p>Le déploiement fait référence au moment où un logiciel est mis à la disposition des utilisateurs. Dans le cas d’un logiciel métier, cela peut se référer à la méthode d’envoi de celui au client, et à la façon dont les utilisateurs finaux pourront l’utiliser. Dans le cas d’une application grand-publique, c’est la méthode de distribution de celle ci au monde entier.</p>

<p>Ce critères se base sur la simplicité du déploiement et les limitations possibles, mesurés tout deux sur une note arbitraire et la vitesse du déploiement qui sera chronométrée.</p>

<h5 id="critères-22--la-maintenance"><strong>Critères 2.2</strong> : La maintenance</h5>

<p>Une fois qu’un logiciel est déployé sur un grand nombre d’appareils divers, il est important de juger de la souplesse avec laquelle il est possible de le mettre à jour (périodiquement, ou “dans l’urgence”) ainsi que l’impact que cette maintenance a sur les utilisateurs. Une bonne mise à jour ne doit pas interrompre le travail de l’usager.</p>

<p>Pour mesurer ce critère, nous jugeront différents sous-critères liés à celui ci avec des notes arbitraires.</p>

<h5 id="critères-23--la-réutilisation"><strong>Critères 2.3</strong> : La réutilisation</h5>

<p>Toujours dans un soucis d’optimisation, il est très bénéfique pour une société de développement informatique de pouvoir compter sur des fonctionnalités qui existent déjà dans des projets, pour les utiliser dans des projets à venir. C’est cette réutilisation du code qui permet à une entreprise d’être de plus en plus performante et de pouvoir répondre aux besoins en un temps optimal.</p>

<p>Le code n’est pas la seule chose qui puisse être réutilisée, des morceaux de l’interface utilisateur sont aussi recyclable selon les technologie utilisées.</p>

<p>Pour mesurer ce critère, nous évalueront les mécanismes qui permettent de rendre du code réutilisable.</p>

<h4 id="critères-3--le-résultat"><strong>Critères 3</strong> : Le résultat</h4>

<p>Enfin, ces derniers critères visent à juger de/des application(s) une fois que leur développement est terminé. Contrairement aux critères précédents, on regarda plutôt ici certaines caractéristiques techniques qu’on comparera d’un point de vu simplement mathématique. Ces caractéristiques seront les résultats de <em>benchmarks</em>, des évaluations précise des critères.</p>

<h5 id="critère-31--utilisation-du-processeur-et-de-la-mémoire"><strong>Critère 3.1</strong> : Utilisation du processeur et de la mémoire</h5>

<p>Les performances d’une application sont un ensemble de mesures qui touche à sa consommation de ressources. Afin de s’exécuter convenablement, un logiciel doit utiliser la puissance de calcul du processeur et stocker/récupérer des données dans la mémoire vive de l’appareil.<br />
Une application trop gourmande en ressource aura donc tendance à “fatiguer” la machine, qui peinera donc à faire fonctionner l’application, ou les autres processus de l’appareil.</p>

<p>Même si la consommation de ressource est importante pour tous les supports matériels, c’est le cas des applicatifs mobile qui est le plus critique en raison des faibles performances des smartphones, comparés aux performances des ordinateurs.</p>

<p>Le but étant de comparer chaque hypothèse sur la même base, nous allons donc établir une liste de moment où nous mesureront l’utilisation du processeur et celle de la mémoire.<br />
Ces moments se basent sur la forme des <em>proofs of concept</em> en question, pour plus d’informations sur la nature de l’application de test, veuillez vous référer au passage listant <a href="#conduit">ses fonctionnalités attendues</a>.</p>

<p>Voici donc les différents instants du cycle d’utilisation de l’application où nous effectueront nos relevés :</p>

<ul>
  <li>Ouverture de l’application et arrivé sur la liste des articles</li>
  <li>Tri des articles par l’utilisation des <em>tags</em> (étiquettes) sur cette même page</li>
  <li>Ouverture de la page d’un utilisateur</li>
  <li>Connexion à l’application</li>
  <li>Publication d’un article</li>
  <li>Suppression d’un article</li>
</ul>

<p>Ces performances sont mesurables et quantifiables grâce à des outils d’analyse.</p>

<h5 id="critère-32--temps-de-réponse-moyen"><strong>Critère 3.2</strong> : Temps de réponse moyen</h5>

<p>On juge une application agréable quand elle “répond au doigt et à l’œil”, en d’autres termes : quand celle ci réagit aux interactions de l’utilisateur dans un temps très restreint. Si un logiciel met plusieurs seconde à sauvegarder un document (par exemple), on jugera l’application lente.</p>

<p>Cette problématique peut même se faire ressentir quand toutes les actions ont un délais de quelques millisecondes. Même si l’utilisateur ne s’en rend pas tout de suite compte, l’application dégagera une impression de lenteur et de frustration.</p>

<p>Le temps de réponse peut-être mesuré en obtenant la différence de temps entre une action de l’utilisateur et la réponse visible à l’écran de cette dernière.<br />
Il est aussi intéressant de calculer le <em>First Contentful Paint</em> ou premier affichage de contenu, le temps que met une application à afficher pour la première fois la page que verra l’utilisateur.</p>

<p>De même, ces relevés se feront sur les mêmes instants du cycle d’utilisation de l’application que pour le <a href="#critère-31--utilisation-du-processeur-et-de-la-mémoire">critère 3.1</a>.</p>

<h5 id="critère-33--le-poids-de-lexécutable"><strong>Critère 3.3</strong> : Le poids de l’exécutable</h5>

<p>Le dernier critère, le plus aisé à mesurer, est le poids final de l’application.<br />
A l’inverse du code source, dont la taille n’a finalement que peu d’importance, le poids du logiciel qui devra loger sur la machine d’un utilisateur lui est plus capital. Encore une fois c’est les smartphones et autres appareils mobile qui sont les plus concernés en raison de leurs espaces de stockage relativement restreintes en comparaison avec les appareils fixes.</p>

<h4 id="comparaisons-des-critères-entres-eux">Comparaisons des critères entres eux</h4>

<p>Ces critères se basent sur des notations différentes : notes, temps, pourcentages, mesures etc.<br />
Afin de réduire ces notations à un pied d’égalité et de pouvoir comparer chaque hypothèses entres elles par la somme de ses résultats, nous appliquerons une formule mathématique qui dégagera au final pour chaque hypothèse un nombre de point.</p>

<p>Ces points auront pour intérêt de comparer les hypothèses entres elles mais il faut garder à l’esprit que cette méthode permet d’avoir un bon aperçu mais n’est en aucun cas un moyen de juger la finalité des hypothèses. Chacune auront des forces et des faiblesses.</p>

<!-- TODO: Parler de la formule ou pas -->

<h3 id="realworld">RealWorld</h3>

<p>Afin de rester dans un contexte technique, et de profiter au mieux du milieu du développement logiciels et de la vision qui l’entoure, nous allons baser nos travaux sur <em>RealWorld</em><sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote">4</a></sup>.</p>

<p><em>RealWorld</em> est un dépôt de code qui regroupe plusieurs <em>proofs of concept</em> cherchant à reproduire une même application avec des technologies différentes.<br />
L’application en question est un clone de <em>Medium</em><sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote">5</a></sup>, un site web d’articles sur des sujets divers, appelé <em>Conduit</em>.</p>

<p>Pour que chaque itération de <em>Conduit</em> soient comparables entre elle, elle doivent toutes suivre les même consignes, le même cahier des charges technique.<br />
L’application est donc scindé en deux parties toujours interchangeables, d’un coté la partie interface utilisateur et de l’autre la gestion des données.</p>

<p>Baser les <em>proofs of concept</em> de cette thèse sur <em>RealWorld</em> permet de mettre en pratique ce dont nous parlions dans le <a href="#Contexte">contexte</a>, à savoir le désir de ne pas répéter les mêmes travaux que ceux qui existent déjà. Nous cherchons à réutiliser l’existant au profit de nouveaux ouvrages.<br />
De plus, <em>RealWorld</em> étant un travail <em>open source</em>, donc libre de droit, il est en parfait accord avec le format de cette thèse qui l’est tout autant, c’est une vision commune dans le monde du développement de logiciels qui mérite d’être partagé.</p>

<h4 id="conduit">Conduit</h4>

<p>Pour mieux présenter <em>Conduit</em> et donc la profondeur de notre application de démonstration, voici une liste des actions qu’il doit être capable de faire, ainsi quelques visuels pour aider à appréhender sa forme.</p>

<h5 id="les-fonctionnalités">Les fonctionnalités</h5>

<ul>
  <li>Authentification
    <ul>
      <li>Connexion</li>
      <li>Inscription</li>
    </ul>
  </li>
  <li>Lecture d’articles
    <ul>
      <li>Flux global</li>
      <li>Flux d’auteurs</li>
      <li>Recherche par étiquettes</li>
      <li>Partage d’articles</li>
    </ul>
  </li>
  <li>Écriture d’articles
    <ul>
      <li>Titre</li>
      <li>Sous Titre</li>
      <li>Corps en texte riche (Markdown <!-- TODO: Définition -->)</li>
      <li>Étiquettes</li>
    </ul>
  </li>
</ul>

<h5 id="visuels-application-bureau">Visuels application bureau</h5>

<p><img src="ConduitDesktopSignIn.png" alt="Authentification bureau" />
<img src="ConduitDesktopHome.png" alt="Page d'accueil bureau" />
<img src="ConduitDesktopEditor.png" alt="Rédaction d'un article bureau" />
<img src="ConduitDesktopArticle.png" alt="Lecture d'un article bureau" /></p>

<h5 id="visuels-application-mobile">Visuels application mobile</h5>

<p><img src="ConduitMobileSignIn.jpg" alt="Authentification mobile" />
<img src="ConduitMobileHome.jpg" alt="Page d'accueil mobile" />
<img src="ConduitMobileEditor.jpg" alt="Rédaction d'un article mobile" />
<img src="ConduitMobileArticle.jpg" alt="Lecture d'un article mobile" /></p>

<h3 id="précisions-sur-les-mesures">Précisions sur les mesures</h3>

<p>Bien entendu, puisque les <em>proofs of concept</em> se baseront sur une base de travail déjà effectué à différents niveau, il ne sera pas possible de baser la mesure du temps de développement sur ma propre quantité de travail uniquement.<br />
Afin de pouvoir estimer au plus précis le temps de travail déjà effectué par la communauté open source, nous allons nous servir d’un outil.</p>

<p>Dans le monde du développement de logiciel, il est coutume d’utiliser un outil dit “de <em>versionning</em>” afin de pouvoir travailler à plusieurs en parallèle sur un même projet et de gérer les différentes versions de l’application.<br />
Parmi ces outils de versionning, le plus connu est <em>Git</em> et c’est celui qui est utilisé dans dans le dépôt de code de <em>RealWorld</em>.<br />
Sans rentrer dans des détails qui n’apporterait pas grand chose à la thèse, il est important d’expliquer rapidement le fonctionnement de <em>Git</em> afin de comprendre comment il est possible d’estimer du temps de travail passé.</p>

<p>Quand un développeur change des fichiers, Git retient la liste des changement, en comparaison avec les fichiers tels qu’ils étaient avant que le développeur ne se mette à travailler. Lorsqu’il décide qu’il a fini sa tâche, il peut choisir de <em>commit</em> (littéralement “créer un engagement”, sous entendu de modification) ses modification et de donner un nom à ces changements afin de les catégoriser.(Exemple : “Ajoute la fonctionnalité de recherche des utilisateurs”).<br />
Ce <em>commit</em> est horodaté et il peux passer à une autre tâche, effectuer les modifications nécessaires, les <em>commit</em> à nouveau etc.</p>

<p>Il existe donc une ligne du temps sur laquelle tous les <em>commits</em> sont positionnés. Cependant ils indiquent tous un endroit dans le temps et non pas une durée de travail. A l’aide d’un algorithme, il est possible de récupérer ces commits et de les grouper ensemble pour reconstituer une “période de travail”.</p>

<p>Par exemple, si un développeur crée ces commits à ces moments :</p>

<div class="mermaid">
graph LR
  C1(Commit 1 - 09:00)
  C2(Commit 2 - 10:30)
  C3(Commit 3 - 11:20)
  C4(Commit 4 - 13:00)
  C5(Commit 5 - 15:30)
  C6(Commit 6 - 16:30)
  C7(Commit 7 - 17:30)
  C1 --&gt; C2 --&gt; C3 --&gt; C4 --&gt; C5 --&gt; C6 --&gt; C7
</div>

<p>On peux lier les <em>commits</em> qui se déroulent à moins de 2h d’écarts, et ainsi dégager les deux périodes de travail de la journée. Il suffit ensuite de mesurer l’écart de temps entre le premier et le dernier <em>commit</em> de la période.</p>

<div class="mermaid">
graph LR
  subgraph Période 1 - 4h
    C1(Commit 1 - 09:00)
    C2(Commit 2 - 10:30)
    C3(Commit 3 - 11:20)
    C4(Commit 4 - 13:00)
  end
  subgraph Période 2 - 2h
    C5(Commit 5 - 15:30)
    C6(Commit 6 - 16:30)
    C7(Commit 7 - 17:30)
  end
  C1 --&gt;|1h30m| C2 --&gt;|50m| C3 --&gt;|1h40m| C4 --&gt;|2h30m| C5 --&gt;|1h| C6 --&gt;|1h| C7
</div>

<p>Le problème c’est qu’il existe pas de manière de savoir à quel moment le développeur a commencé à travailler. Nous n’avons que son premier jalon (à 9h).<br />
Afin d’affiner un peu plus nous pouvons ajouter par défaut une heure de travail à chaque période ce qui donnerais dans cet exemple, une journée de 8h, ce qui semble tout à fait cohérent.</p>

<p>C’est cet algorithme qui va pouvoir nous permettre d’estimer au mieux le temps de travail effectué sur un dépôt de code open source.</p>

<h2 id="valeur-ajoutée-de-cette-recherche">Valeur ajoutée de cette recherche</h2>

<p>Le but de ce travail de recherche est de fournir au sein d’un document synthétique un grand nombre de comparaison entre plusieurs architectures applicatives fréquemment utilisées. Ces comparaisons ont pour objectif d’aider au choix de la technologie au lancement d’un projet de développement informatique et d’accompagner le changement de ces technologies au sein d’une entreprise.</p>

<p>Plutôt que de fonder les réponses aux hypothèses sur les jugements subjectifs de développeurs, cette thèse aborde ce sujet d’un point de vue technique grâce aux <em>proofs of concept</em> et aux <em>benchmarks</em> qui leurs sont liés.<br />
Malgré cela, aucune réponse définitive ne saurait être apporté. Les solutions ont toujours des exceptions dans lesquelles elle brillent plus et le monde du développement de logiciel est en constante croissance, amenant de ce fait de nouveaux outils et de nouvelles solutions très fréquemment.\</p>

<p>C’est au sujet de ce dernier point que ce travail de recherche ne vise donc pas une réponse unique mais plutôt un conseil quand à l’état d’esprit à avoir lorsque l’on considère une architecture applicative. Si les technologies évoluent à une vitesse extraordinaire, les concepts et les notions d’architecture elles, restent toujours valables selon la nature d’un projet.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p><a href="https://slashdata-website-cms.s3.amazonaws.com/sample_reports/EiWEyM5bfZe1Kug_.pdf">SlashData 2019</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p><em>The Pragmatic Programmer</em>, Addison-Wesley, 2000 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p><a href="https://docs.microsoft.com/en-us/lifecycle/products/windows-xp">Fin du support de Windows XP : 2009</a> <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p><a href="https://github.com/gothinkster/realworld">RealWorld</a> <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p><a href="https://medium.com/">Medium</a> <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

    </div><a class="u-url" href="/ThesePro/chapters/introduction" hidden></a>
</article>
<script defer src="/ThesePro/assets/mermaid.min.js"></script>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/ThesePro/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Thèse professionnelle</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Quentin Widlocher</li><li><a class="u-email" href="mailto:quentin@widlocher.com">quentin@widlocher.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/QuentinWidlocher"><svg class="svg-icon"><use xlink:href="/ThesePro/assets/minima-social-icons.svg#github"></use></svg> <span class="username">QuentinWidlocher</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Thèse professionnelle de fin de cursus, sur les applications native, web et hybrides.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
